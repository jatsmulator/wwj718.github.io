<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>writing for time</title><link>/</link><description></description><lastBuildDate>Thu, 21 Jun 2018 00:00:00 +0000</lastBuildDate><item><title>以最佳实践开始你的Django项目</title><link>/cookiecutter-django.html</link><description>&lt;blockquote&gt;
&lt;p&gt;“How long will it take to fix that?” One person, who’d been at the company for years, said, “Three months.” A new person, who’d just come from a world of rapidly provisioned cloud microservices, said, “Three minutes.” They were both correct. That’s how change enters into this world  -- &lt;a href="https://www.bloomberg.com/graphics/2015-paul-ford-what-is-code/"&gt;what is code&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;我近年写过的Django项目基本都采用&lt;a href="https://github.com/pydanny/cookiecutter-django"&gt;cookiecutter-django&lt;/a&gt;来启动&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cookiecutter Django is a framework for jumpstarting production-ready Django projects quickly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/pydanny/cookiecutter-django"&gt;cookiecutter-django&lt;/a&gt;将帮助你快速构建一个生产可用的项目骨架，通过初始化项目时回答几个问题，你将开箱得到许多常用的东西(往往遵循最佳实践)，而避免配置&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/pydanny/cookiecutter-django"&gt;cookiecutter-django&lt;/a&gt;由&lt;a href="https://github.com/pydanny"&gt;pydanny&lt;/a&gt;构建，&lt;a href="https://github.com/pydanny"&gt;pydanny&lt;/a&gt;写过一本Django最佳实践相关的书《Two Scoops of Django》&lt;/p&gt;
&lt;h1&gt;cookiecutter-django介绍&lt;/h1&gt;
&lt;p&gt;cookiecutter-django相关的信息，项目readme里写的很清楚，我简单做些脚注&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://github.com/pydanny/cookiecutter-django#features"&gt;Features&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;For Django 2.0&lt;ul&gt;
&lt;li&gt;Django 2.0的新特性可以看&lt;a href="https://docs.djangoproject.com/en/2.0/releases/2.0/"&gt;这里&lt;/a&gt; &lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.djangoproject.com/en/2.0/releases/2.0/#simplified-url-routing-syntax"&gt;Simplified URL routing syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.djangoproject.com/en/2.0/releases/2.0/#mobile-friendly-contrib-admin"&gt;Mobile-friendly contrib.admin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Works with Python 3.6&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/whatsnew/3.6.html"&gt;What’s New In Python 3.6&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals"&gt;PEP 498: Formatted string literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/whatsnew/3.6.html#pep-526-syntax-for-variable-annotations"&gt;Syntax for variable annotations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Renders Django projects with 100% starting test coverage&lt;/li&gt;
&lt;li&gt;Twitter Bootstrap v4.0.0 (maintained Foundation fork also available)&lt;ul&gt;
&lt;li&gt;使用的是: https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;12-Factor based settings via &lt;a href="https://github.com/joke2k/django-environ"&gt;django-environ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Secure by default. We believe in SSL.&lt;/li&gt;
&lt;li&gt;Optimized development and production settings&lt;/li&gt;
&lt;li&gt;Registration via &lt;a href="https://github.com/pennersr/django-allauth"&gt;django-allauth&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;可以很轻松做到第三方登陆/绑定(oauth)&lt;/li&gt;
&lt;li&gt;关于这个项目致力于解决的问题可以看&lt;a href="https://github.com/pennersr/django-allauth#rationale"&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Comes with custom user model ready to go&lt;/li&gt;
&lt;li&gt;Grunt build for compass and livereload&lt;ul&gt;
&lt;li&gt;前后端分离，不需要这个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Send emails via &lt;a href="https://github.com/anymail/django-anymail"&gt;Anymail&lt;/a&gt; (using &lt;a href="http://www.mailgun.com/"&gt;Mailgun&lt;/a&gt; by default, but switchable)&lt;ul&gt;
&lt;li&gt;邮件发送的调试是个繁琐的问题，&lt;a href="http://www.mailgun.com/"&gt;Mailgun&lt;/a&gt;堪称完美的解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Media storage using Amazon S3&lt;ul&gt;
&lt;li&gt;国内使用S3可能有坑，我偏向使用七牛云&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Docker support using docker-compose for development and production (using Caddy with LetsEncrypt support)&lt;ul&gt;
&lt;li&gt;尽管这个项目不强制使用docker，但我十分偏好docker&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Procfile for deploying to Heroku&lt;ul&gt;
&lt;li&gt;国内用不到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Instructions for deploying to PythonAnywhere&lt;ul&gt;
&lt;li&gt;国内用不到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Run tests with unittest or py.test&lt;/li&gt;
&lt;li&gt;Customizable PostgreSQL version&lt;ul&gt;
&lt;li&gt;PostgreSQL支持json，参考&lt;a href="https://docs.djangoproject.com/zh-hans/2.0/ref/contrib/postgres/fields/"&gt;PostgreSQL specific model fields&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://cookiecutter-django.readthedocs.io/en/latest/"&gt;Documentation&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我倾向于使用docker，文档在&lt;a href="https://cookiecutter-django.readthedocs.io/en/latest/developing-locally-docker.html"&gt;Getting Up and Running Locally With Docker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建议有空多翻阅文档，文档里把开发和部署的大多数问题都谈论了&lt;/p&gt;
&lt;p&gt;一些docker命令偏长，可以自行写个makefile&lt;/p&gt;
&lt;p&gt;服务器的远程管理，推开使用&lt;a href="http://fabric-chs.readthedocs.io/zh_CN/chs/tutorial.html"&gt;fabric&lt;/a&gt;，&lt;a href="http://ansible-tran.readthedocs.io/en/latest/"&gt;ansible&lt;/a&gt;比较重&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://github.com/pydanny/cookiecutter-django#optional-integrations"&gt;optional-integrations&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Serve static files from Amazon S3 or &lt;a href="https://whitenoise.readthedocs.io/"&gt;Whitenoise&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;我偏向把文件存于本地，之后使用七牛云做镜像到本地，来分发(CDN),使用Whitenoise就不必使用nginx来处理静态文件了&lt;/li&gt;
&lt;li&gt;关于文件管理可以看下Caddy的插件&lt;a href="https://github.com/filebrowser/filebrowser"&gt;filebrowser&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Configuration for &lt;a href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Integration with &lt;a href="https://github.com/mailhog/MailHog"&gt;MailHog&lt;/a&gt; for local email testing&lt;/li&gt;
&lt;li&gt;Integration with &lt;a href="https://sentry.io/welcome/"&gt;Sentry&lt;/a&gt; for error logging&lt;ul&gt;
&lt;li&gt;错误提醒及时(邮件通知)，错误信息详细&lt;/li&gt;
&lt;li&gt;可以直接使用官方的云平台，不必自己搭建，目前国内可以正常使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;使用笔记&lt;/h1&gt;
&lt;h3&gt;创建项目&lt;/h3&gt;
&lt;p&gt;我们使用cookiecutter替代&lt;code&gt;django-admin startproject&lt;/code&gt;来初始化项目.&lt;/p&gt;
&lt;p&gt;首先安装依赖&lt;code&gt;pip3 install "cookiecutter&amp;gt;=1.4.0"&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接着开始创建项目&lt;code&gt;cookiecutter https://github.com/pydanny/cookiecutter-django&lt;/code&gt;，你讲被要求回答几个问题，关于项目的信息，以及你需要的组件，我的回答见: &lt;a href="https://gist.github.com/wwj718/ff9ae7fcf268359ac69abf83ff2f53ac"&gt;start_django_project.md&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;运行项目&lt;/h3&gt;
&lt;p&gt;我使用docker来运行项目，我们需要安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/install/#supported-platforms"&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/compose/install/"&gt;Docker Compose&lt;/a&gt;: &lt;code&gt;pip3 install docker-compose&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Build the Stack&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker-compose -f local.yml build&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;生产环境使用&lt;code&gt;production.yml&lt;/code&gt;替代&lt;code&gt;local.yml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第一次build需要一断时间&lt;/p&gt;
&lt;p&gt;如果你添加了python库，需要重新build，不过所花时间要少很多&lt;/p&gt;
&lt;h4&gt;Run the Stack&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker-compose -f local.yml up&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export COMPOSE_FILE=local.yml
docker-compose up 
# docker-compose up -d # 后台运行
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Execute Management Commands&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker-compose -f local.yml run --rm django python manage.py migrate
docker-compose -f local.yml run --rm django python manage.py createsuperuser # django django123
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上每个进程都跑在一个单独的容器中（无状态），进程结束即销毁，数据库使用公共的(由&lt;code&gt;docker-compose up&lt;/code&gt;之前启动的)&lt;/p&gt;
&lt;h4&gt;其他&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Mailhog跑在&lt;code&gt;http://127.0.0.1:8025&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cookiecutter-django.readthedocs.io/en/latest/docker-postgres-backups.html"&gt;数据备份&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;备份: &lt;code&gt;docker-compose -f local.yml exec postgres backup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列出: &lt;code&gt;docker-compose -f local.yml exec postgres backups&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;复制到本地: &lt;code&gt;docker cp 9c5c3f055843:/backups/backup_2018_03_13T09_05_07.sql.gz .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从本地恢复: &lt;code&gt;docker-compose -f local.yml exec postgres restore backup_2018_03_13T09_05_07.sql.gz&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;一些个人意见&lt;/h1&gt;
&lt;p&gt;下边是一些围绕构建一个django项目，我个人所采取的一些策略&lt;/p&gt;
&lt;h3&gt;用户系统&lt;/h3&gt;
&lt;p&gt;使用&lt;a href="https://django-allauth.readthedocs.io/en/latest/overview.html"&gt;django-allauth&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用户账号相关的页面由后端做(django-allauth基本都做了，这部分逻辑考虑步骤可能会有安全问题），此外部分前后端分离&lt;/p&gt;
&lt;p&gt;如果希望注册和登陆更灵活(提供REST接口),可以使用&lt;a href="https://github.com/Tivix/django-rest-auth"&gt;django-rest-auth&lt;/a&gt;。django-rest-auth做的主要工作是让django-allauth暴露出API。&lt;/p&gt;
&lt;h4&gt;关于User model&lt;/h4&gt;
&lt;p&gt;如果你对django自带的User model感到满意, 只是想额外增加field的话, 你可以扩展AbstractUser类，&lt;a href="https://github.com/pydanny"&gt;pydanny&lt;/a&gt;在《Two Scoops of Django》讨论过这块，提到有几种策略。扩展AbstractUser是第一种，目前&lt;a href="https://github.com/pydanny/cookiecutter-django"&gt;cookiecutter-django&lt;/a&gt;用的也是这种&lt;/p&gt;
&lt;h4&gt;添加django-rest-auth&lt;/h4&gt;
&lt;p&gt;添加依赖之后，记得&lt;code&gt;docker-compose -f local.yml build&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Tivix/django-rest-auth"&gt;django-rest-auth&lt;/a&gt;暴露出以下&lt;a href="http://django-rest-auth.readthedocs.io/en/latest/api_endpoints.html"&gt;API&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://127.0.0.1:8000/rest-auth/user/&lt;/code&gt; 将允许你在web页面调试获取用户数据和注册用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://127.0.0.1:8000/rest-auth/registration/&lt;/code&gt; 中注册成功之后，验证邮箱会&lt;a href="https://github.com/Tivix/django-rest-auth/issues/15"&gt;出错&lt;/a&gt;,解决方案参考&lt;a href="https://stackoverflow.com/questions/29725369/improperlyconfigured-at-rest-auth-registration-account-confirm-email"&gt;ImproperlyConfigured at /rest-auth/registration/account-confirm-email&lt;/a&gt;,直接使用allauth提供的confirm_email即可&lt;/li&gt;
&lt;li&gt;登陆(换取token): http POST http://127.0.0.1:8000/rest-auth/login/ username=django password=django123&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;github登陆&lt;/h4&gt;
&lt;p&gt;记录一下，配置github登陆的流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加INSTALLED_APPS : &lt;a href="http://django-allauth.readthedocs.io/en/latest/installation.html"&gt;Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;到github注册client: &lt;a href="http://django-allauth.readthedocs.io/en/latest/providers.html#github"&gt;providers github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在admin中配置github信息: http://127.0.0.1:8000/admin/socialaccount/socialapp/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="oauth github" src="http://wwj-fig-bed.just4fun.site/github_f63bc856.png" /&gt;&lt;/p&gt;
&lt;h3&gt;开发者协同&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git pull&lt;/li&gt;
&lt;li&gt;docker build&lt;/li&gt;
&lt;li&gt;数据库分发备份&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;表单&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采集数据的表单，可以由后端来做，然后放在django admin里管理&lt;ul&gt;
&lt;li&gt;admin + 表单十分迅速&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/pydanny/cookiecutter-django"&gt;cookiecutter-django&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cookiecutter-django.readthedocs.io/en/latest/developing-locally-docker.html"&gt;Getting Up and Running Locally With Docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2018-06-21:cookiecutter-django.html</guid><category>django</category></item><item><title>日志系统与事件记录</title><link>/log-system-event.html</link><description>&lt;p&gt;&lt;img alt="" src="http://wwj-fig-bed.just4fun.site/log_9c5306f2.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;谁控制过去,谁就控制未来  -- 奥威尔《1984》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;日志(log)系统&lt;/h1&gt;
&lt;p&gt;日志是系统的历史。&lt;/p&gt;
&lt;p&gt;让我们将运行着的大型程序视为一个运转着的社会(小型程序可以视为社区)，运转着的社会和运行着的程序，都是一种时间序列上的事件集合。&lt;/p&gt;
&lt;p&gt;发生在社会里的这些事件，被记录下之后，我们称其为历史。而发生在系统里的这些事件，被记录下之后，我们称之为日志。&lt;/p&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;p&gt;那么我们先来谈谈历史吧。&lt;/p&gt;
&lt;p&gt;在银河系旋臂荒凉的一角，一个称为地球的蓝色行星上(where),一种由猿猴进化而来的的生物(who)在某个时间段里(when)生活其中，做着一些在柏拉图看来非常无关紧要的事(what)(柏拉图说&lt;code&gt;但凡是人的事，就没有一件真的非常重要&lt;/code&gt;)。但我们都知道&lt;code&gt;彼之蜜糖 吾之砒霜&lt;/code&gt;,彼之砒霜也可能是吾之蜜糖，柏拉图不屑的这些人间事，在另一些看来却值得大书特书。他们使用一种编码(文字)将发生过的事件(event)记录在某种存储介质中(竹简或是纸张中)(storage)。由于社会里人数如是此之多，事件发生得是如此的密集，这些记录者(历史学家)不得不拣选其中的一些事来记录，而抛弃另外一些。最初的挑选也许是被迫无奈，毕竟你不可能事无巨细得记录所发生的一切，否则记录历史所需的物质材料将大于构建世界的物质材料。这点很好论证，在你记录这段历史时， &lt;code&gt;你在记录历史&lt;/code&gt;这件事本身也正在发生，这很像站在两面镜子之间的你看到的递归景象。如果事无巨细记录一切，光是记录你自己，就将耗尽所有的墨水。由于事件必须被拣选，于是你总是可以&lt;code&gt;客观&lt;/code&gt;地记录历史的同时，挑挑拣拣，让历史呈现出你想要的样子。&lt;/p&gt;
&lt;p&gt;熟悉数据的人们都知道，如果你有挑选样本的权力，为了得出某些特定结论，你其实不必在数据上&lt;code&gt;造假&lt;/code&gt; ：)&lt;/p&gt;
&lt;h3&gt;事件&lt;/h3&gt;
&lt;p&gt;写上边的一段，倒不是为了调侃历史学家。我其实想说，对于一个程序员而言，如何记录日志，记录哪些事件，怎样安全地存储它，是至关重要的，这和历史之于现实社会一样重要，关于这点《1984》已经给我们论述过了。日志虽是对过往发生的事件的记录，但它影响到系统的未来。从日志中，你能看到系统的很多特性(可视化)，你可以了解到使用系统的人的特质(数据分析)，出了问题能够快速定位与修复(sentry)。&lt;/p&gt;
&lt;p&gt;我们回到历史的比喻。在写作历史时，记录事件所用的纸和笔当然是重要的，但要成为一个好的历史学家，你大多的时间可不是在练字或选纸上，如何挑选以及如何记录所发生事件，才是你需要用心之处&lt;/p&gt;
&lt;p&gt;对于构建程序/网站的日志系统也是一样，日志如何写入，如何存储，这些只是基本工作，这些工作并不怎么花时间，你大多的事件需要花在如何挑选事件，如何记录这些事件，之后如何分析处理它们。而之后如何使用它们，又反过来决定了你需要记录哪些事件，以及事件中的哪些信息&lt;/p&gt;
&lt;p&gt;如何在一个程序语言/框架中写入和存储日志，这方面社区已经有大量的讨论，这个问题往往不必重复解决，很多最佳实践都在语言层(如Python)或者框架层(Django)做完了。稍加配置即可&lt;/p&gt;
&lt;p&gt;构建日志系统，我们大量的事件需要花在考虑如何描述事件，以及哪些是我们关心的事件(这是一个业务相关的问题)。关于如何描述事件，尽管我们最终会用代码实现它，但这其实不是一个编程问题，一个事件无非是某些人(who)在某个时间段(when)在某些场合(where)做了某些事(what),至于他为何要做(why)，就是数据挖掘需要做的事了。写作一篇新闻你常常也要考虑这些要素，所以，对事件的描述，本质上和编程无关。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;功夫在诗外&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;日志中的事件&lt;/h1&gt;
&lt;p&gt;在日志这个话题下，技术社区聊到日志系统，关心的主要是系统的架构，用了什么组件，组件之间如何协同。至于如何描述日志，则谈的不多。对于一个初次使用日志的新手，弄懂怎么将日志文本写入系统并不难，此后的存储、备份、归并、分析也多有现成解决方案或最佳实践。工程师在日志记录这件事上能感受到极大的自由，就像你拿着笔在A4纸面前那种自由，似乎什么都能记下，但该记录些什么，又如何表述它们，往往令人不知所措&lt;/p&gt;
&lt;p&gt;本文将论述日志系统的构建，以网站系统为例，其中记录的日志主要围绕与&lt;code&gt;网站用户&lt;/code&gt;相关的事件，至于&lt;code&gt;系统日志&lt;/code&gt;则不在讨论的范围内。我们也将论述以及如何让日志系统服务于其他系统。架构之外，如何描述日志将是这篇文章的重心所在&lt;/p&gt;
&lt;p&gt;文中，我们将以&lt;a href="https://github.com/edx/edx-platform"&gt;open edx&lt;/a&gt;和我们在&lt;a href="http://www.paperweekly.site/"&gt;PaperWeekly&lt;/a&gt;中的构建的网站后端系统为例来说明。&lt;/p&gt;
&lt;p&gt;这两个系统都基于&lt;a href="https://github.com/django/django"&gt;Django&lt;/a&gt;(一个Python web框架)构建，但阅读本文，并不假设你具备Django的知识，当然如果你懂Django最好不过，一些细节可能对你有用，但不懂也不影响阅读。&lt;/p&gt;
&lt;h3&gt;也许你不需要构建自己的日志系统&lt;/h3&gt;
&lt;p&gt;在我们正式开始之前，需要说明的是: 也许你并不需要专门构建一个完整的日志系统。&lt;/p&gt;
&lt;p&gt;这取决于你要干嘛。如果你关心网站的用户流量、Top10入口页面、Top10来源网站、访客停留时间...这些用户指标，&lt;a href="https://www.google.com/analytics/"&gt;google analytics&lt;/a&gt;、&lt;a href="https://tongji.baidu.com/"&gt;Baidu统计&lt;/a&gt;往往是更聪明的选择，花费一盏茶的事件，你就能将它集成到你的网站里。即便是一些自定义的事件跟踪，你也可以利用这些SDK插件来做&lt;/p&gt;
&lt;p&gt;如果你想做的是网站监控，事件告警，诸如你想知道为何每天深夜，网站都会无故崩溃，是昼夜温差变化还是狼人来袭。那么&lt;a href="https://github.com/getsentry/sentry"&gt;Sentry&lt;/a&gt;是你最佳的选择，集成它也只需要一盏茶的功夫。&lt;/p&gt;
&lt;p&gt;如果你还继续往下读，我们假设你有足够的理由构建日志系统了。&lt;/p&gt;
&lt;h3&gt;open edx中的日志系统&lt;/h3&gt;
&lt;p&gt;如果你意识到构建日志系统时，要将事件的描述也包括在内，那么当你看到open edx复杂的日志系统，你就不会那么吃惊。其中的复杂之处，多是对事件的描述，他们为此构建了多层的抽象，而对事件的描述必然涉及到大量的业务逻辑和概念，所以读起来是十分晦涩的。我并不建议深挖这一块。即便你的系统以open edx为主体，我也不建议去拓展和hack它的日志系统。&lt;/p&gt;
&lt;p&gt;理由如下:&lt;/p&gt;
&lt;p&gt;首先成本高昂，关于edx日志系统，我在一篇文章里有细述:&lt;a href="https://blog.just4fun.site/explore-Open-edX-tracking-system.html"&gt;explore Open edX tracking system&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在架构层面，这里边并没有什么复杂性，无非是利用了Django的log机制(其实是对python logging模块的包装)，繁琐的是层层的包装。我觉得去理解和hack这些包装是痛苦且不必要的。原因是日志在存储层面无非是一种文本序列，你可以分别/分布式地存储它们。如果最终的分析需要合并，有很多优秀的工具帮你归并日志（诸如&lt;a href="https://github.com/elastic/beats"&gt;Beats&lt;/a&gt;、Logstash之类）。日志的聚合是最后考虑的问题，而且你大可放心。&lt;/p&gt;
&lt;p&gt;下边我们说说open edx中值得我们学习的地方，先说说open edx中对事件的描述。这部分是这块令人头疼的主要原因。而头疼的原因是这里牵扯到大量的业务逻辑和领域概念。&lt;/p&gt;
&lt;p&gt;典型的事件如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;wwj&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;event_source&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;server&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;edx.course.enrollment.deactivated&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;referer&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;http:\/\/localhost:8001\/container\/i4x:\/\/edX\/DemoX\/vertical\/69dedd38233a46fc89e4d7b5e8da1bf4?action=new&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;accept_language&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;en-US,en;q=0.8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2014-01-26T00:28:28.388782+00:00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;agent&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Mozilla\/5.0 (Windows NT 6.1; WOW64; Trident\/7.0; rv:11.0) like Gecko&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;page&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;host&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;courses.edx.org&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;session&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;a14j3ifhskngw0gfgn230g&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;context&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;user_id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9999999&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;org_id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;edX&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;course_id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;edX\/DemoX\/Demo_Course&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;path&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\/change_enrollment&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;ip&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;NN.NN.NNN.NNN&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;event&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;course_id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;edX\/DemoX\/Demo_Course&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;user_id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9999999&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;mode&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;honor&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;event_type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;edx.course.enrollment.deactivated&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是一条相对简单的事件。但我们可以看到基于json的日志，表现力极强(因为支持嵌套结构)，你可以轻松将你关心的信息，都组织在嵌套json结构中。但也别忘了&lt;code&gt;扁平优于嵌套&lt;/code&gt;。这个例子里另一个具有参考价值的是对一些业务无关的信息，诸如username、event_source、referer这些都是通用的概念，这就是我们提到的事件描述相关的部分。&lt;/p&gt;
&lt;p&gt;如果你对细节有更多的兴趣，可以参考我之前的文章:&lt;a href="https://blog.just4fun.site/edx-tracking-logs-data-research.html"&gt;基于tracking logs的数据分析&lt;/a&gt;.如果你的兴趣在open edx本身，那么我之前和同事一起翻译的&lt;a href="https://blog.just4fun.site/events-in-the-tracking-logs.html"&gt;Tracking Logs 中的事件(翻译)&lt;/a&gt;你可能有兴趣。&lt;/p&gt;
&lt;p&gt;open edx中的日志系统给我的影响主要是:你可以直接使用django的日志系统并选择json作为日志格式，此外我们就不必深入了。当然，如果你对open edx本身熟悉，过一遍它的事件类型，作为案例学习，看看它是如何选择事件信息(这需要里理解业务)，也是很有益的&lt;/p&gt;
&lt;h1&gt;PaperWeekly中的日志系统&lt;/h1&gt;
&lt;p&gt;我们在PaperWeekly构建日志系统时，架构层面参考了open edx。我们日志系统同时服务于:推荐系统和数据可视化（对google analytics做些补充）&lt;/p&gt;
&lt;p&gt;我们先做个概览：在&lt;a href="http://www.paperweekly.site/"&gt;PaperWeekly&lt;/a&gt;网站后台我们首先将事件pub出去,对此感兴趣的订阅者自行订阅它(典型订阅者包括消息系统和日志系统)，每个订阅者都跑在一个task中(celery)&lt;/p&gt;
&lt;p&gt;我们最初是在构建通知系统时，发现我们需要考虑如何来描述事件(诸如我们要通知用户A:&lt;code&gt;你发表的文章B被用户C点赞了&lt;/code&gt;)，为了描述这点，我们需要关心事件:&lt;code&gt;用户C点赞了文章B&lt;/code&gt;， 而后在构建推荐系统时，发现我们同样需要关心这些事件。于是我们索性把这几块一并做了。利用pub/sub机制来解耦。&lt;/p&gt;
&lt;p&gt;通知系统和日志系统很大程度是重叠的。核心都是&lt;code&gt;事件&lt;/code&gt;,那么怎么描述事件就摆到桌面来了。&lt;/p&gt;
&lt;p&gt;在关于通知系统的讨论中，这块被讨论得多些，我之前也专门整理了一篇文章：&lt;a href="https://blog.just4fun.site/notification-system-thinking-concept-and-Implementation.html"&gt;notification system思路、概念与实现&lt;/a&gt;,我们在paperweekly，所做的基本是对这篇文章提到的概念做了实现，这块@izuo做了大量出色的工作。 最近@izuo将这块的工作梳理在&lt;a href="http://monad.site/2018/05/30/notification-system/"&gt;消息系统的概念、设计与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如何把你关心的事件结构化，一种好的策略是把它们描述为AVOT的结构（我们之所以需要AVOT是因为我们需要结构化事件，我们之所以需要结构化事件，是因为程序善于处理结构化数据，否则你就需要处理一堆脏数据了）。AVOT分别是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Actor&lt;/li&gt;
&lt;li&gt;Verb&lt;/li&gt;
&lt;li&gt;Object&lt;/li&gt;
&lt;li&gt;Target&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们举例说明: &lt;code&gt;用户C将文章B放入收藏夹D中&lt;/code&gt;,让我们把对应关系写上:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Actor: 用户C&lt;/li&gt;
&lt;li&gt;Verb: 放入&lt;/li&gt;
&lt;li&gt;Object: 文章B&lt;/li&gt;
&lt;li&gt;Target: 收藏夹D&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这其中可能引起疑惑的是Object和Target的区别，两者都是名词，如何决定两个名词中哪个对应Object，哪个对应Target。就功能而言你当然可以随意(它们本质只是4个容器)，但最好使用它们的语义，这样你不至于把自己搞乱了，target的意义你可以通过这个英文句子来理解:&lt;code&gt;Erik is pinning Hawaii to his Places to Visit board.&lt;/code&gt;,在这里&lt;code&gt;his Places to Visit board&lt;/code&gt;是Target。&lt;/p&gt;
&lt;p&gt;至于前边我们提到的&lt;code&gt;用户C点赞了文章B&lt;/code&gt;，我们把它视为省略了Target&lt;/p&gt;
&lt;p&gt;你可以试试用AVOT去描述你所关心的事件，你会发现它具有极强的变现力！&lt;/p&gt;
&lt;!--
我们先试着把句子转为`把A当到/加到B`这种结构，B就是Target

前边我们提到的`用户C点赞了文章B`,我们将它转化为:`用户C把他的赞给了文章B`，在此我们将`赞`作为名词使用，在系统里，我们也将它构建为实体，这样以来，我们就能同时直到一个人点赞了哪些文章，以及一篇文章被哪些人点赞了。
--&gt;

&lt;h3&gt;实现细节&lt;/h3&gt;
&lt;p&gt;最后我们来讨论一下实现细节&lt;/p&gt;
&lt;p&gt;PaperWeekly和open edx一样直接使用了Django的日志系统， 我们为用户日志，单独构建了一个handle，以区别与系统日志&lt;/p&gt;
&lt;p&gt;当然，关于日志的这些细节无关紧要，你可以参考你正在使用的框架，文档里论述应该都很全面&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &amp;#39;track_log&amp;#39;: {
            &amp;#39;level&amp;#39;: &amp;#39;INFO&amp;#39;,
            &amp;#39;class&amp;#39;: &amp;#39;logging.handlers.RotatingFileHandler&amp;#39;,
            &amp;#39;maxBytes&amp;#39;: 1024 * 1024 * 10,  # 10MB
            &amp;#39;backupCount&amp;#39;: 100,  # 10MB * 100 # 1G
            &amp;#39;filename&amp;#39;: os.path.join(TRACK_LOG_PATH,
                                     &amp;#39;track_log.log&amp;#39;), 
            &amp;#39;formatter&amp;#39;: &amp;#39;track_log&amp;#39;
        },
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至于它的formatter则是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &amp;#39;track_log&amp;#39;: {
            &amp;#39;format&amp;#39;: &amp;#39;%(message)s&amp;#39;
        },
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;track_log formatter只忠实地记录打印message，而message则由python中的类去构建,这些消息类就是对我们前边谈到的AVOB的实践，你需要使用AVOB去具体描述你所关心的事件(通常与业务相关)&lt;/p&gt;
&lt;p&gt;补充一些细节:我们前头说到日志系统主动去sub系统发布的事件，具体的实现利用了Django的signal机制。为了让这些记录不影响用户访问，我们将记录log的task放到了celery里&lt;/p&gt;
&lt;h4&gt;前端事件&lt;/h4&gt;
&lt;p&gt;如果你同时还关心发生在前端的事件，有两个办法解决，其一是使用&lt;a href="https://www.google.com/analytics/"&gt;google analytics&lt;/a&gt;这类前端分析工具，它允许你自定义事件。其二是在后端写一个通用接口，前端构建好事件(json数据)，发送给后台，后台把它当作一般的事件数据，记录到日志中即可，最好加上&lt;code&gt;日志来源&lt;/code&gt;这个属性:&lt;code&gt;event_source&lt;/code&gt;,这点open edx考虑得很周到。&lt;/p&gt;
&lt;h3&gt;服务于其他系统&lt;/h3&gt;
&lt;p&gt;前边提到我们让日志系统服务于推荐系统和数据可视化&lt;/p&gt;
&lt;p&gt;推荐系统会根据用户的行为日志计算出用户的的feed流，实时更新。这部分的实现细节是：我们将日志同步到一台独立的计算机器上，分布式地算出用户feed流之后，回推到网站后端-&amp;gt;用户主页.&lt;/p&gt;
&lt;p&gt;至于数据可视化我们则用了ELK来做，先用Logstash使json平坦化，然后根据业务需要，可视化这些数据。对于日志中不包含的数据，可以通过查询数据库得到，诸如日志中只要记录username，我们就可以还原出user对象(通过查询数据库)。这部分我们也是参考了open edx数据分析这块的的做法，这块的一个建议是，尽量不要再服务器运行高峰期去操作生产服务器。如果你的查询很少，可以直接查询生产服务器，如果查询多且耗性能的话，建议把数据库同步到计算节点上，做本地查询。&lt;/p&gt;
&lt;!--
# 事件

# 事件记录

物是人非

新闻6要素 

如何描述一个事件

存储和分析，相比较而言更为简单

如何描述一个event ， 我们可能想到新闻六要素

功夫在诗外

事件的触发
事件的描述
事件的存储

最难在于事件的描述  使用avob

于是消息系统 也可以用

在paperweekly，我们是这样做的，知乎也是这样做，事件总线

以一个典型的例子  

我们最后，再切到技术的视角下，关心技术实现的问题

### 基于django的实现
你也可以使用其他语言来实现它

我们在django下做的实现


我们将其用于产生feed流，用户的消息通知，以及网站的log


这一块和open edx很像，可以参考我之前的文章

--&gt;

&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97"&gt;维基百科 服务器日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.jobbole.com/89674/"&gt;The Log：每个程序员都应该知道有关实时数据的统一抽象（1）概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.just4fun.site/notification-system-thinking-concept-and-Implementation.html"&gt;notification system思路、概念与实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2018-05-18:log-system-event.html</guid><category>architecture</category></item><item><title>对jupyter notebook的分析、扩展与hack</title><link>/jupyter-notebook-architecture-hack.html</link><description>&lt;h1&gt;大纲&lt;/h1&gt;
&lt;p&gt;本文关心代码在jupyter notebook里从前端传往后端的过程，并试图获取到钩子，因为我最近项目的缘故(可以参考&lt;a href="http://blog.just4fun.site/jupyter-notebook-architecture.html"&gt;我之前的文章&lt;/a&gt;)，分析完通信过程，我将演示如何扩展和hack jupyter notebook&lt;/p&gt;
&lt;p&gt;在接下来动手实践部分将演示如何将其以iframe嵌入到外部网页网页中(在概念上是嵌入一种资源)&lt;/p&gt;
&lt;h1&gt;实验环境&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;ubuntu 14.04&lt;/li&gt;
&lt;li&gt;python 2.7.6&lt;/li&gt;
&lt;li&gt;jupyter 4.3.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;安装jupyter(notebook)&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virtualenv env
. env/bin/activate
pip install jupyter #  安装完后是4.3
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;运行&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;jupyter notebook --no-browser --port 5000 --ip=0.0.0.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我将其跑在5000端口，并接收所有ip的请求&lt;/p&gt;
&lt;p&gt;关于启动参数，不熟悉的同学可以参考我之前&lt;a href="http://blog.just4fun.site/jupyter-summary.html"&gt;文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是第一次手动登陆，需要输入token，如果你没加入--no-brower，会自动打开&lt;code&gt;http://127.0.0.1:5000/?token=d311b2834ac7337157c54aaba8d9a524ce48f7597c91xxxx&lt;/code&gt;,验证一次之后，浏览器就有cookie了，之后只需要&lt;code&gt;127.0.0.1:5000&lt;/code&gt;就可访问&lt;/p&gt;
&lt;h1&gt;分析&lt;/h1&gt;
&lt;h3&gt;从websocket入手&lt;/h3&gt;
&lt;p&gt;打开一个新的notebook: &lt;code&gt;http://127.0.0.1:5000/notebooks/Untitled1.ipynb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从chrome调试面板的Network可以看到，有个websocket:&lt;code&gt;ws://127.0.0.1:5000/api/kernels/d13a50b0-6baa-4d5e-8564-95f224daxxxx/channels?session_id=F552491A7C0448A2B5567DE1A71Cxxxx&lt;/code&gt;，代码经由它往后端发送，也经由它接收后台返回的信息&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://wwj-fig-bed.just4fun.site/jupyter_notebool6c197bf1.png" /&gt;&lt;/p&gt;
&lt;p&gt;当我们运行上头的print("hello world")时，往后台发送如下数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;header&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:{&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;msg_id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;29A5EFC0B11848BE97B66D6E947AEB71&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;session&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;7C49DDC342FD43AA8F5624B08CD7BDAB&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;msg_type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;execute_request&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;5.0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;metadata&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:{},&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:{&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;code&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;print(\&amp;quot;hello world\&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;silent&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;store_history&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;user_expressions&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:{},&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;allow_stdin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;stop_on_error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;buffers&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:[],&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;parent_header&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:{},&lt;/span&gt;&lt;span class="nt"&gt;&amp;quot;channel&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;shell&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来有5个frames&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://wwj-fig-bed.just4fun.site/jupyter_notebook1122d9a7.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中包含了代码执行的结果&lt;/p&gt;
&lt;p&gt;那么我们只要模拟建立这样的websocket，就拿到所要的钩子了，可以自如地运行代码&lt;/p&gt;
&lt;h3&gt;从页面入手&lt;/h3&gt;
&lt;p&gt;除了建立websocket，我们也可以找找js中钩子&lt;/p&gt;
&lt;p&gt;这个问题在stack overflow里找到解答，方法如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var handle_output = function (data) {console.log(data);}

var callbacks = {
            iopub : {output : handle_output,}
}

var kernel = IPython.notebook.kernel;
kernel.execute(&amp;quot;print(&amp;#39;hello&amp;#39;)&amp;quot;,callbacks)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="http://wwj-fig-bed.just4fun.site/jupyter_notebookf07db6f1.png" /&gt;&lt;/p&gt;
&lt;p&gt;如此一来我们找到了第二种钩子 &lt;/p&gt;
&lt;p&gt;消息是用websocket传输的，你可以试试实时性:&lt;code&gt;kernel.execute("for i in range(5):import time;time.sleep(1);print('hello')",callbacks)&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;嵌入到外部页面中&lt;/h1&gt;
&lt;p&gt;接下来的部分，演示如何将jupyter notebook嵌入到外部页面里，如此一来可以利用jupyter强大的特性做很多好玩的东西，诸如各种语言的线上IDE&lt;/p&gt;
&lt;p&gt;首先建立一个前端页面(my_test.html)，然后以iframe的方式引入jupyter notebook(关于iframe的属性可以参考&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe"&gt;这里&lt;/a&gt;),接下来在外部网页中与其互操作&lt;/p&gt;
&lt;p&gt;从建立网页开始&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;wwj&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;iframe&lt;/span&gt; &lt;span class="na"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;600&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;height&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;400&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;notebook&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://127.0.0.1:5000/notebooks/Untitled1.ipynb?token=c81b15a38f4fdfebe67cab0400b9feb0e60325f35bafxxxx&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;iframe&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;wwjtest&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;噢报错了，这个问题这里有描述:&lt;a href="http://stackoverflow.com/questions/26435653/how-do-i-embed-an-ipython-notebook-in-an-iframe-new"&gt;How do I embed an Ipython Notebook in an iframe&lt;/a&gt;,解决方案这个比较靠谱:&lt;a href="https://github.com/jupyter/notebook/issues/284"&gt;Can't use Notebook inside an iframe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解决方案是生成配置文件:&lt;code&gt;jupyter notebook --generate-config&lt;/code&gt;，做些配置。往&lt;code&gt;~/.jupyter/jupyter_notebook_config.py&lt;/code&gt;加入&lt;code&gt;c.NotebookApp.tornado_settings = { 'headers': { 'Content-Security-Policy': "frame-ancestors 'self' *" } }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;现在没有问题啦 (注意不要直接打开my_test.html，使用网络访问它(python -m SimpleHTTPServer))&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://wwj-fig-bed.just4fun.site/jupyter_notebookb1f5c27a.png" /&gt;&lt;/p&gt;
&lt;h3&gt;采用postMessage来传递消息&lt;/h3&gt;
&lt;p&gt;因为jupyter与外部页面可能存在跨域问题（别怕，最复杂的情况，也就是跨域了），我打算采用HTML5 postMessage来处理这个问题&lt;/p&gt;
&lt;p&gt;postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。&lt;/p&gt;
&lt;h3&gt;往iframe里发送消息&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;notebook&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;notebook&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;code&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;print(&amp;#39;hello&amp;#39;)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;notebook&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;contentWindow&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;postMessage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;扩展jupyter notebook&lt;/h3&gt;
&lt;p&gt;为了在jupyter notebook中监听到外部网页发过来的消息，并给予响应，我们需要为其写js扩展，哈哈别紧张，jupyter设计得很漂亮，扩展它很简单(可能需要安装:&lt;code&gt;pip install  widgetsnbextension&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;~/.ipython/nbextensions&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;创建我们的扩展(iframe_extension.js):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
      &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;_on_load&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;iframe extension running!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;message&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;the iframe get:&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;postMessage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;data from  iframe extension&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;})&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;load_ipython_extension&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;_on_load&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;在外部网页等待iframe的消息&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;message&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;response from notebook:&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大功告成！&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Wed, 22 Mar 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2017-03-22:jupyter-notebook-architecture-hack.html</guid><category>architecture</category></item><item><title>jupyter notebook架构分析</title><link>/jupyter-notebook-architecture.html</link><description>&lt;h1&gt;我的痛点&lt;/h1&gt;
&lt;p&gt;最近在折腾blockly4pi(暂未开源)，这是一个很好玩的项目，试图用blockly来控制树莓派，将硬件功能积木化，从而降低硬件编程入门门槛&lt;/p&gt;
&lt;p&gt;在这个项目中，我将blockly用作代码生成器，这和官方的定位相同，虽然你也可以以其他方式使用它，但我认为将其用作代码生成器，并保持积木的灵活与可组合性(do one thing and do well)，能发挥极大的威力&lt;/p&gt;
&lt;p&gt;我把对blockly的理解都写在这里了：&lt;a href="http://blog.just4fun.site/blockly-overview.html"&gt;blockly入门与介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这个项目中，我遇到一个很典型的问题：将浏览器里的代码丢到机器上运行，然后拿到运行结果，最好能即使给出运行过程信息&lt;/p&gt;
&lt;p&gt;大概像这样&lt;/p&gt;
&lt;p&gt;&lt;img alt="架构图" src="" /&gt; &lt;/p&gt;
&lt;p&gt;实际上这是大多web IDE在做的事&lt;/p&gt;
&lt;p&gt;我的第一个版本很粗暴，用户拼接好积木,blockly生成代码后，点击运行，代码(python)被post到树莓派，在那里执行,然后返回运行结果&lt;/p&gt;
&lt;p&gt;这个过程粗暴到无从批评，因为到处都是槽点，灵活性和扩展性都很糟糕。&lt;/p&gt;
&lt;p&gt;第二个版本采用了websocket(flask-socketio)来通信，后台也加入了事件机制，这样一来阻塞的问题得到解决，c/s两边能及时传递运行时信息&lt;/p&gt;
&lt;p&gt;后来意识到我填坑流的泪，都是当初选web框架时脑子进的水,我需要一个异步非阻塞的框架 ，而不是对flask修修补补,一会加上多线程，一会儿加上事件机制，如果最初就选择&lt;a href="https://github.com/tornadoweb/tornado"&gt;tornado&lt;/a&gt;省去多少时间&lt;/p&gt;
&lt;h1&gt;踏破铁鞋&lt;/h1&gt;
&lt;p&gt;再往后我发现，我特么就是在重造一个轮子，这个轮子在jupyter notebook已经实现得非常漂亮了&lt;/p&gt;
&lt;p&gt;jupyter notebook之前叫ipython notebook，我是它的脑残粉，之前对其做过介绍:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.just4fun.site/use-ipython-notebook.html"&gt;使用IPython Notebook来学习编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.just4fun.site/jupyter-summary.html"&gt;jupyter使用小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;jupyter notebook的架构&lt;/h1&gt;
&lt;p&gt;在&lt;a href="http://jupyter.org/"&gt;jupyter主页&lt;/a&gt;上，官方有对其做个简要说明:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Jupyter Notebook is based on a set of open standards for interactive computing. Think HTML and CSS for interactive computing on the web. These open standards can be leveraged by third party developers to build customized applications with embedded interactive computing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jupyter notebook基于若干开放标准，可以将其视为三个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Notebook Document Format : 基于JSON的开放文档格式，完整地记录用户的会话(sessions)和代码、说明性的文本、方程以及富文本输出&lt;/li&gt;
&lt;li&gt;Interactive Computing Protocol: 该协议用于连接Notebook和内核，基于JSON数据、ZMQ以及WebSockets&lt;/li&gt;
&lt;li&gt;The Kernel: 使用特定编程语言实际跑代码的地方，并将输出返回给用户。内核也返回tab键补全信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;架构图&lt;/h3&gt;
&lt;p&gt;上边提到的三个部分直接的关系如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://jupyter.readthedocs.io/en/latest/_images/notebook_components.png" /&gt;&lt;/p&gt;
&lt;p&gt;于是我们可以回答&lt;a href="https://github.com/alex/what-happens-when"&gt;what happens when&lt;/a&gt;这类经典问题,当我们点击运行&lt;code&gt;print("hello world")&lt;/code&gt;时发生了什么&lt;/p&gt;
&lt;p&gt;从上图我们可以看出发生了这样一些事：用户在浏览器里写代码，点击运行后，代码从浏览器发送给Web服务器(tornado)，接着从Web服务器发送消息到Kernel(python)执行代码，在Kernel中执行代码产生的输出/错误会被发送给Web服务器，接着发往给浏览器,用户于是看到输出，这个过程说起来很绕，实际执行飞快无比&lt;/p&gt;
&lt;p&gt;如果你对jupyter的生态有兴趣，那么下边这张架构图，能让你看出各个项目直接的关系,如果你只关心jupyter notebook，它也给出了更为细致的信息&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://jupyter.readthedocs.io/en/latest/_images/repos_map.png" /&gt;&lt;/p&gt;
&lt;p&gt;如果你对通信过程很感兴趣，这一看下这张图（消息的传输用到了 ZeroMQ）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://jupyter-client.readthedocs.io/en/latest/_images/frontend-kernel.png" /&gt;&lt;/p&gt;
&lt;p&gt;如果你对ZeroMQ有兴趣，可以看我之前的笔记&lt;a href="http://blog.just4fun.site/mq-note.html"&gt;消息队列中间件学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从途中我们可以看到主要利用了ZeroMQ的Publisher-Subscriber模式来做通信&lt;/p&gt;
&lt;h1&gt;回到我的项目上&lt;/h1&gt;
&lt;p&gt;对上边&lt;code&gt;what happens when&lt;/code&gt;的回答稍作修改，我们就能得到一个改良版的blocklu4pi的架构，而且这类架构几乎适用于任何的web IDE类型的项目。blockly正在流行，这套架构之后大有用武之地&lt;/p&gt;
&lt;p&gt;修改后的通信流程为: 用户在浏览器里拖拽blockly积木块生成代码,点击运行后，代码从浏览器发送给Web服务器(tornado)，接着从Web服务器发送消息到Kernel(python)执行代码，在Kernel中执行代码产生的输出/错误会被发送给Web服务器，接着发往给浏览器,用户于是看到输出&lt;/p&gt;
&lt;p&gt;上述两个流程的区别仅在于产生代码的方式不同而已，jupyter是用户手写，而blockly是用积木生成，余下过程一!模!一!样！&lt;/p&gt;
&lt;h1&gt;交互式探索&lt;/h1&gt;
&lt;p&gt;为了对通信和调用过程有更细致的了解，我们可以在notebook里进行交互式探索, REPL优雅之处在于让我们方便地做实验与探索未知&lt;/p&gt;
&lt;p&gt;&lt;a href="http://hyry.dip.jp/tech/slice/slice.html/36"&gt;这篇文章&lt;/a&gt;给了我们一个思路来观察Kernel是如何接收、运行和返回消息:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户代码和Kernel在同一进程中执行，因此我们可以通过一些特殊的代码研究Kernel是如何接收、运行并返回消息的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者接下来演示了如何通过&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gc, threading, traceback, inspect查看了Kernel是如何接收和发送消息，以及如何运行用户代码的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;非常有意思的一篇分析,不过因为时间过去较久，架构有些调整，所以我这边给出最新的交互数据&lt;/p&gt;
&lt;p&gt;我的版本为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;jupyter 4.3.0
ipython 5.2.2
notebook 4.4.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下边是实验数据&lt;/p&gt;
&lt;h3&gt;Kernel中的Socket对象&lt;/h3&gt;
&lt;p&gt;通过gc模块的get_objects()遍历进程中所有的对象&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;gc&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_objects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_objects&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;class_name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;kapp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_objects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;IPKernelApp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;#&amp;lt;ipykernel.kernelapp.IPKernelApp at 0x108a22d10&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;kapp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shell_socket&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kapp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iopub_socket&lt;/span&gt; &lt;span class="c1"&gt;# (&amp;lt;zmq.sugar.socket.Socket at 0x108a8d328&amp;gt;, &amp;lt;ipykernel.iostream.BackgroundSocket at 0x108aa3850&amp;gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;IPKernelApp对象的shell_socket和iopub_socket分别用于接收命令和广播代码执行输出，对应于架构图部分表示通信过程的图中绿色和红色端口&lt;/p&gt;
&lt;p&gt;在Notebook中执行用户输入的&lt;code&gt;print&lt;/code&gt;时，会经由iopub_socket将输出的内容传送给Web服务器，最终在Notebook界面中显示&lt;/p&gt;
&lt;p&gt;我们知道python中，print语句实际上会调用sys.stdout完成输出工作&lt;/p&gt;
&lt;p&gt;那么Kernel中的sys.stdout是什么对象&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt; &lt;span class="c1"&gt;#&amp;lt;ipykernel.iostream.OutStream object at 0x108a9cfd0&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pub_thread&lt;/span&gt; &lt;span class="c1"&gt;# &amp;lt;ipykernel.iostream.IOPubThread at 0x108aa32d0&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前头说到iopub_socket用于广播代码的输出，可以推测sys.stdout是一个对kapp.iopub_socket进行包装的OutStream对象(sys.stdout经由kapp.iopub_socket广播出来)&lt;/p&gt;
&lt;p&gt;我们可以发现&lt;code&gt;sys.stderr&lt;/code&gt;和&lt;code&gt;sys.stdout&lt;/code&gt;是同个对象(内存地址完全相同)&lt;/p&gt;
&lt;h3&gt;Kernel中的线程&lt;/h3&gt;
&lt;p&gt;通过threading.enumerate()可以获得当前进程中的所有线程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;
&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;[&amp;lt;_MainThread(MainThread, started 140736413283264)&amp;gt;,&lt;/span&gt;
&lt;span class="sd"&gt; &amp;lt;Thread(Thread-2, started daemon 123145475149824)&amp;gt;,&lt;/span&gt;
&lt;span class="sd"&gt; &amp;lt;HistorySavingThread(IPythonHistorySavingThread, started 123145485709312)&amp;gt;,&lt;/span&gt;
&lt;span class="sd"&gt; &amp;lt;Heartbeat(Thread-3, started daemon 123145479356416)&amp;gt;,&lt;/span&gt;
&lt;span class="sd"&gt; &amp;lt;ParentPollerUnix(Thread-1, started daemon 123145489915904)&amp;gt;]&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;各个线程的功能为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主线程(MainThread)接收来自前端的命令，执行用户代码，并输出代码的执行结果。&lt;/li&gt;
&lt;li&gt;HistorySaving线程用户将用户输入的历史保存到Sqlite数据库中&lt;/li&gt;
&lt;li&gt;Heartbeat线程用于定时向前端发送消息，用于检测心跳&lt;/li&gt;
&lt;li&gt;ParentPollerUnix线程，监视父进程，如果父进程退出，则保证Kernel进程也退出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;用户代码的执行&lt;/h3&gt;
&lt;p&gt;通过在用户代码中执行traceback.print_stack()输出整个执行堆栈&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/runpy.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;162&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;_run_module_as_main&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pkg_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/runpy.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;72&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;_run_code&lt;/span&gt;
    &lt;span class="k"&gt;exec&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;run_globals&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/ipykernel/__main__.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;launch_new_instance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/traitlets/config/application.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;658&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;launch_instance&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/ipykernel/kernelapp.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;474&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
    &lt;span class="n"&gt;ioloop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IOLoop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/zmq/eventloop/ioloop.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;177&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
    &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ZMQIOLoop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/tornado/ioloop.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;887&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
    &lt;span class="n"&gt;handler_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd_obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/tornado/stack_context.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;275&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;null_wrapper&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/zmq/eventloop/zmqstream.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;440&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;_handle_events&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_handle_recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/zmq/eventloop/zmqstream.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;472&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;_handle_recv&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_run_callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/zmq/eventloop/zmqstream.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;414&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;_run_callback&lt;/span&gt;
    &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/tornado/stack_context.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;275&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;null_wrapper&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/ipykernel/kernelbase.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;276&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dispatcher&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dispatch_shell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/ipykernel/kernelbase.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;228&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dispatch_shell&lt;/span&gt;
    &lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;idents&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/ipykernel/kernelbase.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;390&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;execute_request&lt;/span&gt;
    &lt;span class="n"&gt;user_expressions&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;allow_stdin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/ipykernel/ipkernel.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;196&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;do_execute&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_cell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;store_history&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;store_history&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;silent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;silent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/ipykernel/zmqshell.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;501&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;run_cell&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ZMQInteractiveShell&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_cell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/IPython/core/interactiveshell.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;2717&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;run_cell&lt;/span&gt;
    &lt;span class="n"&gt;interactivity&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;interactivity&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;compiler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;compiler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/IPython/core/interactiveshell.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;2827&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;run_ast_nodes&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_code&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;/Users/wwj/env/lib/python2.7/site-packages/IPython/core/interactiveshell.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;2881&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;run_code&lt;/span&gt;
    &lt;span class="k"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;code_obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;user_global_ns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;user_ns&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;ipython-input-2-2e94e8c65f66&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;traceback&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_stack&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从中可以看到用户代码是如何被调用的&lt;/p&gt;
&lt;p&gt;在KernelApp对象的start()中，调用ZeroMQ中的ioloop.start()处理来自shell_socket的消息。当从Web服务器接收到execute_request消息时，将调用kernel.execute_request()方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kapp.kernel.execute_request #&amp;lt;bound method IPythonKernel.execute_request of &amp;lt;ipykernel.ipkernel.IPythonKernel object at 0x10c09f910&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在execute_request()中调用shell对象的如下方法最终执行用户代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print kapp.kernel.shell.run_cell #&amp;lt;bound method ZMQInteractiveShell.run_cell of &amp;lt;ipykernel.zmqshell.ZMQInteractiveShell object at 0x10c09f950&amp;gt;&amp;gt;
print kapp.kernel.shell.run_ast_nodes #&amp;lt;bound method ZMQInteractiveShell.run_ast_nodes of &amp;lt;ipykernel.zmqshell.ZMQInteractiveShell object at 0x10c09f950&amp;gt;&amp;gt;
print kapp.kernel.shell.run_code #&amp;lt;bound method ZMQInteractiveShell.run_code of &amp;lt;ipykernel.zmqshell.ZMQInteractiveShell object at 0x10c09f950&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;shell对象在其user_global_ns和user_ns属性在执行代码，这两个字典就是用户代码的执行环境，实际上它们是同一个字典&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print globals() is kapp.kernel.shell.user_global_ns #True
print globals() is kapp.kernel.shell.user_ns #True
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;查看shell_socket的消息&lt;/h3&gt;
&lt;p&gt;可以利用inspect.stack()获得前面的执行堆栈中的各个frame对象，从而查看堆栈中的局域变量的内容，这样可以观察到Kernel经由shell_socket接收的回送的消息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;inspect&lt;/span&gt;
&lt;span class="n"&gt;frames&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;inspect&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;dispatch_shell&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;request&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;execute_request&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;reply&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上代码在kernel里执行的时候，通信过程已经完成，所以我们可以拿到frames["request"]，frames["reply"]在&lt;code&gt;print "hello world"&lt;/code&gt;之前执行，所以frames["reply"]不包含代码运行的结果&lt;/p&gt;
&lt;p&gt;Kernel接收到的消息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;request&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;f_locals&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;msg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;{&amp;#39;buffers&amp;#39;: [],&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;content&amp;#39;: {&amp;#39;allow_stdin&amp;#39;: True,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;code&amp;#39;: &amp;#39;import inspect\nframes = {}\nfor info in inspect.stack():\n    if info[3] == &amp;quot;dispatch_shell&amp;quot;:\n        frames[&amp;quot;request&amp;quot;] = info[0]\n    if info[3] == &amp;quot;execute_request&amp;quot;:\n        frames[&amp;quot;reply&amp;quot;] = info[0]\nprint &amp;quot;hello world&amp;quot;&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;silent&amp;#39;: False,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;stop_on_error&amp;#39;: True,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;store_history&amp;#39;: True,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;user_expressions&amp;#39;: {}},&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;header&amp;#39;: {&amp;#39;date&amp;#39;: datetime.datetime(2017, 3, 8, 9, 35, 4, 596768, tzinfo=tzutc()),&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;msg_id&amp;#39;: &amp;#39;0616032D8FE8469780CA0A4A89D578AD&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;msg_type&amp;#39;: &amp;#39;execute_request&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;session&amp;#39;: &amp;#39;6DDDE94601B247779637A3F3A0F2F573&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;username&amp;#39;: &amp;#39;username&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;version&amp;#39;: &amp;#39;5.0&amp;#39;},&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;metadata&amp;#39;: {},&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;msg_id&amp;#39;: &amp;#39;0616032D8FE8469780CA0A4A89D578AD&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;msg_type&amp;#39;: &amp;#39;execute_request&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;parent_header&amp;#39;: {}}&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kernel对上述消息的应答&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frames&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;reply&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;f_locals&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;reply_msg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;{&amp;#39;content&amp;#39;: {u&amp;#39;execution_count&amp;#39;: 4,&lt;/span&gt;
&lt;span class="sd"&gt;  u&amp;#39;payload&amp;#39;: [],&lt;/span&gt;
&lt;span class="sd"&gt;  u&amp;#39;status&amp;#39;: u&amp;#39;ok&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  u&amp;#39;user_expressions&amp;#39;: {}},&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;header&amp;#39;: {&amp;#39;date&amp;#39;: datetime.datetime(2017, 3, 8, 9, 35, 4, 613218, tzinfo=tzutc()),&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;msg_id&amp;#39;: u&amp;#39;d4d00f59-d6a3739d12069c2fb8c0a23f&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;msg_type&amp;#39;: u&amp;#39;execute_reply&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;session&amp;#39;: u&amp;#39;337fb80f-b3760e2423717a4de6ff4ba8&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;username&amp;#39;: u&amp;#39;wwj&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;version&amp;#39;: &amp;#39;5.0&amp;#39;},&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;metadata&amp;#39;: {&amp;#39;dependencies_met&amp;#39;: True,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;engine&amp;#39;: u&amp;#39;7b3fd05a-613d-4c6e-a789-f952660d4edf&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;started&amp;#39;: datetime.datetime(2017, 3, 8, 17, 35, 4, 598015),&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;status&amp;#39;: u&amp;#39;ok&amp;#39;},&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;msg_id&amp;#39;: u&amp;#39;d4d00f59-d6a3739d12069c2fb8c0a23f&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;msg_type&amp;#39;: u&amp;#39;execute_reply&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;parent_header&amp;#39;: {&amp;#39;date&amp;#39;: datetime.datetime(2017, 3, 8, 9, 35, 4, 596768, tzinfo=tzutc()),&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;msg_id&amp;#39;: &amp;#39;0616032D8FE8469780CA0A4A89D578AD&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;msg_type&amp;#39;: &amp;#39;execute_request&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;session&amp;#39;: &amp;#39;6DDDE94601B247779637A3F3A0F2F573&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;username&amp;#39;: &amp;#39;username&amp;#39;,&lt;/span&gt;
&lt;span class="sd"&gt;  &amp;#39;version&amp;#39;: &amp;#39;5.0&amp;#39;},&lt;/span&gt;
&lt;span class="sd"&gt; &amp;#39;tracker&amp;#39;: &amp;lt;zmq.sugar.tracker.MessageTracker at 0x10b266f50&amp;gt;}&lt;/span&gt;
&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的应答消息并非代码的执行结果，代码的输出在执行代码时已经经由sys.stdout-&amp;gt;iopub_socket发送给Web服务器了。&lt;/p&gt;
&lt;h1&gt;手写一jupyter&lt;/h1&gt;
&lt;p&gt;jupyter已经演变得非常庞大，许多的代码都在打磨细节，如此一来直接阅读源码，会陷入各种细枝末节里，不大好一眼看到核心逻辑。为了理解原理，溯本求源是一个好方法，一种策略是翻到早起的版本或者commit&lt;/p&gt;
&lt;p&gt;另一种策略是看一些类似的小项目(专注在原理实现)，&lt;a href="https://github.com/fperez/zmq-pykernel"&gt;zmq-pykernel&lt;/a&gt;是一个不错的实验，它基于ZeroMQ来实现，非常小巧&lt;/p&gt;
&lt;h1&gt;写一个自己的kernel&lt;/h1&gt;
&lt;p&gt;尽管官方文档有相应教程,不过直接从&lt;a href="https://github.com/Calysto/metakernel"&gt;metakernel&lt;/a&gt;开始是个不错的选择,metakernel为我们做了许多起步阶段的工作，具体可以参考&lt;a href="https://github.com/Calysto/metakernel#features"&gt;metakernel features&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jupyter.org/"&gt;jupyter.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jupyter.readthedocs.io/en/latest/architecture/content-architecture.html"&gt;doc jupyter Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jupyter-client.readthedocs.io/en/latest/messaging.html"&gt;Messaging in Jupyter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hyry.dip.jp/tech/slice/slice.html/36"&gt;IPython Notebook架构之Kernel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2017-03-08:jupyter-notebook-architecture.html</guid><category>architecture</category></item></channel></rss>