<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>writing for time</title><link>/</link><description></description><atom:link href="/feeds/ying-jian.rss.xml" rel="self"></atom:link><lastBuildDate>Sun, 24 Dec 2017 00:00:00 +0000</lastBuildDate><item><title>micro:bit使用笔记</title><link>/microbit-notes.html</link><description>&lt;p&gt;折腾micro:bit过程中记录的笔记。涉及资源、工具、文档等。&lt;/p&gt;
&lt;p&gt;如果你想获取更多micro:bit相关资源，可以到&lt;a href="https://github.com/wwj718/awesome-microbit-zh"&gt;awesome-microbit-zh&lt;/a&gt;里淘金&lt;/p&gt;
&lt;h1&gt;micro:bit概述&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;micro:bit是一个小型的可编程计算机，旨在使学习与教学变得轻松有趣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;micro:bit是一款由BBC（英国广播电视公司）推出的为青少年编程教育设计的微型电脑开发板(43 mm × 52 mm), 集成了ARM Cortex-M0处理器、低功耗蓝牙，加速度计，磁力计，三个按钮，5 x 5 LED点阵以及GPIO。&lt;/p&gt;
&lt;p&gt;使用micro:bit可以快速地把你脑子中好玩的想法付诸实践，做出酷炫的小发明。&lt;/p&gt;
&lt;p&gt;microbit官网有许多统计数据表明这个板子取得的教育成就和受欢迎程度:&lt;a href="http://microbit.org/teach/"&gt;Research Findings&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;技术参数&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="http://tech.microbit.org/docs/hardware/assets/microbit-overview.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5x5 LED点阵&lt;/li&gt;
&lt;li&gt;3个按钮（2个用于用户操作，1个用于复位）&lt;/li&gt;
&lt;li&gt;23个GPIO引脚&lt;/li&gt;
&lt;li&gt;Nordic nRF51822 - 16 MHz 32位ARM Cortex-M0 微控制器，256 KB 闪存，16 KB RAM，2.4 GHz 蓝牙低功耗无线网络。ARM内核可以在16 MHz或32.768 kHz之间切换. 实际运行代码的地方&lt;/li&gt;
&lt;li&gt;NXP/Freescale KL26Z - 接口芯片／接口MCU. 48MHz 的ARM Cortex-M0+ 内核微控制器，其中有全速USB 2.0 OTG控制器，用作USB和Nordic nRF51822控制器之间的通信接口&lt;/li&gt;
&lt;li&gt;NXP/Freescale MMA8652 - 3轴加速度传感器(I²C总线)&lt;/li&gt;
&lt;li&gt;NXP/Freescale MAG3110 - 3轴磁力仪传感器I²C总线（用作指南针和金属探测器）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;microbit有两个两个MCU(nRF51822/KL26Z)，可能一开始会让人有点疑惑，它们的关系如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     PC
      ^                                                    +----------------------------+
      |        +---------------------+                     |       TARGET MCU           |
      |        |   INTERFACE MCU     |                     | +------------------------+ |
      |        |                     |                     | |      Application       | |
      |        | +-----------------+ |     SWD             | +------------------------+ |
      |  USB   | |                 | +---------------------+ | micro:bit runtime DAL  | |
      +--------+ |    DAPLink      | &amp;lt;----------+          | +------------------------+ |
        * Mass | +-----------------+ |     UART |          | |          | |           | |
        Storage| +-----------------+ |          |          | |   mbed   | | SoftDevice| |
               | |   Bootloader    | |          +------------&amp;gt;          | |           | |
        * UART | +-----------------+ |                     | +----------+ +-----------+ |
               +---------------------+                     +----------------------------+
        * CMSIS-DAP
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更多细节参考:&lt;a href="http://tech.microbit.org/software/daplink-interface/"&gt;DAPlink and the USB interface&lt;/a&gt;&lt;/p&gt;
&lt;!--
### 历史
micro:bit旨在鼓励孩子开始编程和构建新事物，而不是成为软件/媒体消费者.它可以与树莓派协同工作。
--&gt;

&lt;h3&gt;开放性&lt;/h3&gt;
&lt;h4&gt;硬件开源&lt;/h4&gt;
&lt;p&gt;关于硬件部分，两部分关键信息可以一窥Microbit 的内部设计:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://tech.microbit.org/hardware/schematic/"&gt;线路图(schematics)&lt;/a&gt;, 可以看到主要零件的链接方式及设计.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tech.microbit.org/hardware/reference-design/"&gt;reference design&lt;/a&gt;, 这部分的数据可以帮助进一步了解Microbit 的设计及变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于硬件部分更多的描述参考:&lt;a href="http://tech.microbit.org/hardware/"&gt;Hardware Description&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;兰卡斯特大学（Lancaster University）构建了完整的microbit的硬件抽象（C/C++），包括一个事件调度器和消息总线，这对个人用户和更高级的语言都是有用的（比如Python），这儿有完整的&lt;a href="https://lancaster-university.github.io/microbit-docs/ubit/"&gt;API文档&lt;/a&gt;和&lt;a href="http://lancaster-university.github.io/microbit-docs/online-toolchains/"&gt;入门指南&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;软件开源&lt;/h4&gt;
&lt;p&gt;而为micro:bit编程的软件/web平台，目前基本都开源&lt;/p&gt;
&lt;h1&gt;开始编程&lt;/h1&gt;
&lt;h3&gt;可选编程工具&lt;/h3&gt;
&lt;p&gt;有多种工具可以为microbit编程，包括图形化界面(makecode等)、Python、C++等。我们先在架构层面关注一下microbit的运行时，如下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://tech.microbit.org/docs/software/assets/dal-4032c.png" /&gt;&lt;/p&gt;
&lt;p&gt;代码的执行过程为(如果你对更多细节感兴趣，可以参考&lt;a href="http://tech.microbit.org/software/"&gt;the micro:bit Software Ecosystem&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://tech.microbit.org/docs/software/assets/overview.png" /&gt;&lt;/p&gt;
&lt;p&gt;尽管有许多可选工具，官方推荐我们使用两种工具来为microbit编程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由微软打造的&lt;a href="https://makecode.microbit.org/#"&gt;JavaScript Blocks Editor(makecode)&lt;/a&gt;: makecode是一个图形化工具，对新手友好&lt;/li&gt;
&lt;li&gt;来自python社区的&lt;a href="http://python.microbit.org/v/1"&gt;Python Editor&lt;/a&gt;: 使用python代码驱动microbit，适合进阶的孩子&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你偏好使用离线的编辑器,推荐&lt;a href="https://codewith.mu/"&gt;Mu&lt;/a&gt;和&lt;a href="http://kittenbot.cn/bbs/forum.php?mod=viewthread&amp;amp;tid=156&amp;amp;highlight=makecode"&gt;Makecode离线版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多可选择的编程工具，你可以参考这里:&lt;a href="https://github.com/wwj718/awesome-microbit-zh#%E7%BC%96%E7%A8%8B"&gt;awesome-microbit-zh 编程&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;图形化编程&lt;/h3&gt;
&lt;p&gt;如果你选择图形化编程,目前的可选方案有几个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://makecode.microbit.org/"&gt;makecode&lt;/a&gt;： 提供一个基于浏览器的模拟器和积木编程环境，堆叠好的积木块最终将生成JavaScript (TypeScript)代码。PXT支持代码的双向转换！&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.microbit.co.uk/app/#create:tomwku"&gt;Code Kingdoms&lt;/a&gt; - 基于图形界面的编程工具，帮助用户从拖曳式编程到文本编程(JavaScript)的过渡.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://lab.open-roberta.org/"&gt;Open Roberta Lab&lt;/a&gt; - 为机器人编程设计的积木时编程环境, 通过将堆叠好的积木生成MicroPython代码来支持microbit.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://microbit.site/editor-zh-hans.html"&gt;microbit zh&lt;/a&gt;: 国内社区提供的在线工具,堆叠好的积木块生成python代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在浏览器中的编程环境内置了编译器（可离线使用，十分适合在教室或公共计算机上使用）,代码块转换为hex文件的过程如下&lt;/p&gt;
&lt;p&gt;更多细节,参考这里:&lt;a href="http://tech.microbit.org/docs/software/assets/browser-build-pipeline.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Python 编程&lt;/h3&gt;
&lt;p&gt;microbit上跑了一个MicroPython解释器(一个移植版本):&lt;a href="https://github.com/bbcmicrobit/micropython"&gt;bbcmicrobit/micropython&lt;/a&gt;.这一点可以通过上边那张关于运行时的图种看出&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/bbcmicrobit/micropython"&gt;bbcmicrobit/micropython&lt;/a&gt;源码中包含了很多使用python驱动microbit的&lt;a href="https://github.com/bbcmicrobit/micropython/blob/master/examples/"&gt;examples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既然microbit上跑了MicroPython，那我们就可以用为MicroPython打造的工具来为microbit编程(诸如picocom),关于MicroPython相关的工具和资源，我之前写了这篇文章:&lt;a href="http://blog.just4fun.site/micropython-notes.html"&gt;MicroPython使用笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这儿有一些工具方便在python脚本和hex文件中转化:&lt;a href="https://github.com/bbcmicrobit/micropython/tree/master/tools"&gt;tools&lt;/a&gt;、&lt;a href="https://github.com/ntoll/uflash"&gt;uflash&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;一些有趣项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wwj718/bitio"&gt;bitio&lt;/a&gt;: 把bitio当成一个IO设备。可以用这库很方便地与电脑脚本，把bitio当成可编程的外设，强烈推荐！&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tech.microbit.org/bluetooth/apps-and-examples/"&gt;Bluetooth Apps and Examples&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.bittysoftware.com/"&gt;bitty software apps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/wwj718/scratch2-microbit"&gt;scratch2-microbit&lt;/a&gt;: 使用microbit来控制scratch2中的角色&lt;/li&gt;
&lt;li&gt;&lt;a href="https://microbit-playground.co.uk/howto/GUIZero-pySerial-microbit-how-to-connect"&gt;pySerial Microbit GUI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;课程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://microbit.org/zh-CN/teach/"&gt;microbit teach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://microbit.org/zh-CN/teach/code-org-fundamentals/"&gt;Micro:bit Lessons Aligned to Code.org's CS Fundamentals&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="http://microbit.org/zh-CN/2017-12-04-code_org_loops_2/"&gt;Course E - Loops 2 - Nested Loops and Scoreboards&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://microbit.org/zh-CN/2017-12-04-code_org_conditionals-1/"&gt;Course F - Conditionals 1 - Conditionals with the Weather Predictor&lt;/a&gt;:有配套的教师资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://microbit-playground.co.uk/"&gt;python游乐场&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://microbit-playground.co.uk/components/PIR-sensor"&gt;PIR Sensor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.bbc.co.uk/programmes/articles/S3Htm99fVV4XrtncmZfPQT/bbc-micro-bit-classroom-activities"&gt;BBC micro:bit classroom activities&lt;/a&gt;: 模拟器、作业、slides&lt;/li&gt;
&lt;li&gt;&lt;a href="https://makecode.microbit.org/projects"&gt;Microsoft 14 Week Curriculum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.microbit.co.uk/STEM"&gt;STEM Centre Lessons&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://microbit0.blob.core.windows.net/pub/hohwmegr/STEM-Learning-Acceleration-lesson-plan.pdf"&gt;Acceleration&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="http://microbit.org/assets/documents/us_stem_curriculum/stem-acceleration-teacher-notes.pdf"&gt;Acceleration STEM Experiment 教师笔记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;FAQ&lt;/h1&gt;
&lt;h3&gt;与Arduino对比&lt;/h3&gt;
&lt;p&gt;相比与Arduino，micro:bit具有免装驱动,易上手，电子模块集成度高，支持时下热门的多种编程语言等优势，节省了教学资源成本的同时也大大增加了可玩性和拓展空间。关于这方面的讨论可以参考:&lt;a href="http://kittenbot.cn/bbs/forum.php?mod=viewthread&amp;amp;tid=81"&gt;Microbit和arduino有什么关系？&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;microbit在拖入hex文件后将自动弹出并自动运行程序&lt;/h3&gt;
&lt;p&gt;microbit的flash文件系统完全是虚拟，这就是为什么在写入新文件之后驱动器会自动弹出，当你把hex文件拖到MICROBIT上，它并没有被写入到闪存里，而是直接流到nRF51822(target MCU)中&lt;/p&gt;
&lt;p&gt;这方便的讨论参考:&lt;a href="http://tech.microbit.org/software/daplink-interface/"&gt;DAPlink and the USB interface|Files on the MICROBIT Drive&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Micro_Bit"&gt;wikipedia Micro Bit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tech.microbit.org/"&gt;microbit developer community&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="http://tech.microbit.org/software/"&gt;he micro:bit Software Ecosystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tech.microbit.org/hardware/"&gt;Hardware Description&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tech.microbit.org/software/runtime-mbed/"&gt;The micro:bit runtime and mbed programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/TWmicrobit/p/6984285.html"&gt;Microbit 硬件架构介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/wwj718/awesome-microbit-zh"&gt;awesome-microbit-zh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://microbit.hackster.io/"&gt;microbit.hackster.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mc.dfrobot.com.cn/forum.php?mod=viewthread&amp;amp;tid=23903"&gt;BBC Micro:bit是什么和microbit怎么玩起来 中文教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kittenbot.cn/bbs/forum.php?mod=viewthread&amp;amp;tid=81"&gt;Microbit和arduino有什么关系？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tech.microbit.org/software/daplink-interface/"&gt;DAPlink and the USB interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://lancaster-university.github.io/microbit-docs/online-toolchains/"&gt;Web-based C/C++ environments supporting the runtime&lt;/a&gt;
&amp;lt;!--
https://github.com/bbcmicrobit/micropython/blob/master/tools/pyboard.py  是一个分支&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;http://mc.dfrobot.com.cn/forum.php?mod=viewthread&amp;amp;tid=30029  电子琴&lt;/p&gt;
&lt;p&gt;http://mc.dfrobot.com.cn/forum.php?mod=viewthread&amp;amp;tid=30010  计步器&lt;/p&gt;
&lt;p&gt;https://sites.google.com/site/hardwaremonkey/home/handshake  实际使用 实验&lt;/p&gt;
&lt;p&gt;https://github.com/lancaster-university/quiz-bit  投票程序&lt;/p&gt;
&lt;p&gt;https://github.com/ubirch/pxt-ubirch 发送数据到云端&lt;/p&gt;
&lt;p&gt;http://warksjammy.blogspot.kr/2017/07/bitio-blogs-in-one-place.html?view=timeslide  例子 用于控制minecrft  树莓派&lt;/p&gt;
&lt;p&gt;图形化&lt;/p&gt;
&lt;p&gt;http://www.micropython.org.cn/bbs/forum.php?mod=viewthread&amp;amp;tid=273&amp;amp;extra=&lt;/p&gt;
&lt;p&gt;microbit和scratch连接&lt;/p&gt;
&lt;p&gt;https://github.com/vecsei/Scratchbit&lt;/p&gt;
&lt;p&gt;https://www.youtube.com/watch?v=nJengUwURdE&amp;amp;feature=youtu.be&lt;/p&gt;
&lt;p&gt;https://github.com/wwj718/scratch2-microbit  成功！！！ 非常酷&lt;/p&gt;
&lt;p&gt;https://mryslab.github.io/s2m/
--&amp;gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Sun, 24 Dec 2017 00:00:00 +0000</pubDate><guid>tag:,2017-12-24:microbit-notes.html</guid><category>microbit</category></item><item><title>MicroPython使用笔记</title><link>/micropython-notes.html</link><description>&lt;p&gt;折腾MicroPython过程中记录的笔记。涉及资源、工具、文档等。&lt;/p&gt;
&lt;h1&gt;MicroPython概述&lt;/h1&gt;
&lt;p&gt;MicroPython是Python3(Python 3.4)的精简高效实现，包括Python标准库的一小部分(此外，MicroPython还包括访问硬件的"machine"等模块)，可在微控制器和受限环境中运行。&lt;/p&gt;
&lt;p&gt;MicroPython包括了REPL，列表解析，生成器，异常处理等高级功能，适合运行在只有256k的代码空间和16k的RAM的芯片上。&lt;/p&gt;
&lt;p&gt;MicroPython尽可能与普通Python(CPython)兼容，方便你轻松将代码从桌面环境移植到微控制器或嵌入式系统。&lt;/p&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;p&gt;MicroPython最初由澳大利亚程序员兼物理学家Damien George 在2013年&lt;a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers"&gt;Kickstarter众筹活动&lt;/a&gt;之后创建.
最初的的Kickstart活动通过pyboard微控制器发布了MicroPython.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://ksr-ugc.imgix.net/assets/011/591/465/2de115d40b068db02a2186953fd970ac_original.jpg?crop=faces&amp;amp;w=1552&amp;amp;h=873&amp;amp;fit=crop&amp;amp;v=1463684927&amp;amp;auto=format&amp;amp;q=92&amp;amp;s=6f12ee64adce1799eeeb1ddcc73231a4" /&gt;&lt;/p&gt;
&lt;p&gt;但MicroPython支持许多基于ARM的体系结构的芯片。MicroPython已经可以运行在Arduino，ESP8266，ESP32...(具体参考&lt;a href="http://micropython.org/download"&gt;MicroPython downloads
&lt;/a&gt;)。2016年，MicroPython的一个分支运行在的BBC microbit上。&lt;/p&gt;
&lt;h3&gt;开放性&lt;/h3&gt;
&lt;p&gt;MicroPython使用C99(C语言的官方标准第二版)编写,源码在&lt;a href="https://github.com/micropython/micropython"&gt;这儿&lt;/a&gt;，MicroPython内核非常开放,采用 MIT 协议. &lt;/p&gt;
&lt;p&gt;可以自由使用和或者修改MicroPython: 个人使用、教育和商业产品...&lt;/p&gt;
&lt;p&gt;pyboard的的硬件部分开放在这里:&lt;a href="https://github.com/micropython/pyboard"&gt;micropython/pyboard&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;pyboard&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pyboard2edf9179.png" /&gt;&lt;/p&gt;
&lt;p&gt;我目前手中的这块板子是 PYBv1.1&lt;/p&gt;
&lt;p&gt;引脚图如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://micropython.org/resources/pybv11-pinout.jpg" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://micropython.org/"&gt;技术参数&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;STM32F405RG微控制器&lt;/li&gt;
&lt;li&gt;168 MHz Cortex M4 CPU，带硬件浮点&lt;/li&gt;
&lt;li&gt;1024KiB闪存ROM和192KiB RAM&lt;/li&gt;
&lt;li&gt;微型USB连接器，用于电源和串行通信&lt;/li&gt;
&lt;li&gt;Micro SD卡插槽，支持标准和高容量SD卡&lt;/li&gt;
&lt;li&gt;3轴加速度计 (MMA7660)&lt;/li&gt;
&lt;li&gt;可选电池备份的实时时钟&lt;/li&gt;
&lt;li&gt;有29个GPIO&lt;/li&gt;
&lt;li&gt;3x12位模数转换器，16引脚，4路模拟接地屏蔽&lt;/li&gt;
&lt;li&gt;2x12位数模转换器，可在引脚X5和X6上使用&lt;/li&gt;
&lt;li&gt;1个复位和1个用户开关&lt;/li&gt;
&lt;li&gt;4个led灯(红，绿，黄、蓝)&lt;/li&gt;
&lt;li&gt;板载3.3V LDO稳压器，能够提供高达250mA的输入电压范围3.6V至16V&lt;/li&gt;
&lt;li&gt;ROM中的DFU引导加载程序，便于升级固件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外值得一提的特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多种架构（x86, x86-64, ARM, ARM Thumb, Xtensa）&lt;/li&gt;
&lt;li&gt;快速的启动速度（运行到boot.py只需要150毫秒，PYBv1.1以168MHz运行）&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;_thread&lt;/code&gt;支持多线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;烧写系统&lt;/h3&gt;
&lt;p&gt;参考: &lt;a href="https://github.com/micropython/micropython/wiki/Pyboard-Firmware-Update"&gt;Pyboard Firmware Update&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;按以下步骤进行(我在mac下进行，linux下基本一致，windows用户参考&lt;a href="https://github.com/micropython/micropython/wiki/Pyboard-Firmware-Update#on-windows---using-stm-dfuse"&gt;On Windows - Using STM DfuSe&lt;/a&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将DFU pin 与 3.3V pin用杜邦线连在一起&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pyboarda177888d.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装dfu-util&lt;ul&gt;
&lt;li&gt;mac下是: brew install dfu-util&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;列出设备&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo dfu-util -l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;备份旧系统(可选): &lt;code&gt;sudo dfu-util --alt 0 --upload pyboard-original.dat -s:524288&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;下载MicroPython固件:&lt;a href="http://micropython.org/download/"&gt;MicroPython downloads&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;我选择了PYBv1.1板子，最新的threading版本的:&lt;a href="http://micropython.org/resources/firmware/pybv11-thread-20171220-v1.9.3-207-ga1d85d61.dfu"&gt;v1.9.3-207-ga1d85d61&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开始烧录: &lt;code&gt;sudo dfu-util --alt 0 -D pybv11-thread-20171220-v1.9.3-207-ga1d85d61.dfu&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你也可以使用&lt;a href="https://github.com/micropython/micropython/blob/master/tools/pydfu.py"&gt;pydfu.py&lt;/a&gt;来进行烧录&lt;/p&gt;
&lt;h1&gt;开始编程&lt;/h1&gt;
&lt;p&gt;有多种方式可以在pyboard中运行代码，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脚本运行&lt;/li&gt;
&lt;li&gt;REPL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下边分别论述：&lt;/p&gt;
&lt;h3&gt;脚本运行&lt;/h3&gt;
&lt;p&gt;我们在pyboard上运行硬件的hello world:&lt;code&gt;点亮led灯&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用USB数据线将pyboard连到电脑里，pyboard将以U盘模式挂载到电脑上（PYBFLASH）&lt;/li&gt;
&lt;li&gt;进入PYBFLASH，编辑main.py，内容为&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pyb&lt;/span&gt;
&lt;span class="n"&gt;red_led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pyb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="n"&gt;red_led&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;正常弹出pyboard(否则内容会丢失)，按下reset按钮(RST)按下,即可点亮红灯&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的教材参考:&lt;a href="http://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/index.html"&gt;MicroPython tutorial for the pyboard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PYBFLASH目录下有个&lt;code&gt;boot.py&lt;/code&gt;文件，该文件是启动引导脚本，默认加载main.py&lt;/p&gt;
&lt;p&gt;通过修改该文件，你还可以选择pyboard的挂载模式，诸如将其挂载为鼠标，有兴趣的同学可以点开这个文件，里边有相应注释。更多细节可以参考:&lt;a href="http://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/usb_mouse.html"&gt;Making the pyboard act as a USB mouse&lt;/a&gt;。当你想把pyboard从鼠标模式改回来时,需要使用安全模式:&lt;a href="http://docs.micropython.org/en/latest/pyboard/pyboard/general.html#boot-modes"&gt;boot-modes&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;REPL&lt;/h3&gt;
&lt;p&gt;REPL(Read Evaluate Print Loop)提供了绝佳的学习和探索环境。Python用户对此应该深有感触&lt;/p&gt;
&lt;p&gt;在Mac/Linux下我偏好使用串口调试工具&lt;code&gt;picocom&lt;/code&gt;来连接硬件（更多的工具参考:&lt;a href="http://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/repl.html#getting-a-micropython-repl-prompt"&gt;Getting a MicroPython REPL prompt&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;/dev/tty.usb*&lt;/code&gt;识别出你的pyboard(通过观察pyboard插入前后的变化，多出的设备即为pyboard)，我的pyboard地址为&lt;code&gt;/dev/tty.usbmodem1412&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行: &lt;code&gt;picocom /dev/tty.usbmodem1412 -b115200&lt;/code&gt; 即可进入REPL&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pyboardc1cdf8bd.png" /&gt;&lt;/p&gt;
&lt;p&gt;注: picocom使用的是emacs的快捷键,退出为:&lt;code&gt;Ctrl-a Ctrl-x&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;更多工具&lt;/h3&gt;
&lt;p&gt;以上两种方式在开发过程都有些缺陷。以main.py脚本运行的方式，每次需要编辑文件、弹出设备、点击重置。步骤太多&lt;/p&gt;
&lt;p&gt;而在REPL中运行，又不放便保存代码，也不好写多行脚本(函数、类、循环)，这一点上ptpython做的很好，可惜目前不能用于MicroPython。下边介绍一些方便调试的工具&lt;/p&gt;
&lt;h4&gt;ampy&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/adafruit/ampy"&gt;ampy&lt;/a&gt;是Adafruit出品的一个工具，通过串口连接与MicroPython交互，提供许多实用的工具。允许你在命令行里操控MicroPython。诸如运行本机脚本,往MicroPython板子上传下载文件&lt;/p&gt;
&lt;p&gt;安装:&lt;code&gt;pip install adafruit-ampy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;帮助: &lt;code&gt;ampy --help&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调试脚本(假设设备为&lt;code&gt;/dev/tty.usbmodem1412&lt;/code&gt;): &lt;code&gt;ampy --port /dev/tty.usbmodem1412 run /tmp/a.py&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a href="https://github.com/adafruit/jupyter_micropython_kernel"&gt;Jupyter MicroPython Kernel&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;使用jupyter来交互式地编程&lt;/p&gt;
&lt;h3&gt;错误提醒与处理&lt;/h3&gt;
&lt;p&gt;参考:&lt;a href="http://docs.micropython.org/en/latest/pyboard/pyboard/general.html?highlight=error#errors-flashing-leds"&gt;Errors: flashing LEDs&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果main.py文件中有语法错误，板子上会交替闪烁红灯和绿灯.如果四个灯同时闪烁，你需要恢复出厂设置&lt;/li&gt;
&lt;li&gt;恢复出厂设置（刷完固件之后的状态）:&lt;a href="http://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/reset.html"&gt;Safe mode and factory reset&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第三方模块&lt;/h3&gt;
&lt;p&gt;参考:&lt;a href="http://docs.micropython.org/en/latest/pyboard/reference/packages.html"&gt;Distribution packages, package management, and deploying applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和python一样，你也可以方便地安装第三方模块包:&lt;a href="https://github.com/micropython/micropython-lib"&gt;micropython-lib&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你的板子可以联网(8266的板子可以，pyboard也有networking版本)，你可以直接使用upip来安装、管理第三方包。&lt;/p&gt;
&lt;p&gt;如果你的板子不能联网(目前的pyboard默认不能联网)，你可以使用交叉安装包(Cross-installing packages):现在本地安装包，然后挪到板子里(import路径下即可)。具体而言你会用到这条命令:&lt;code&gt;micropython -m upip install -p install_dir micropython-pystone_lowmem&lt;/code&gt;, 之后你把install_dir拖到板子里即可&lt;/p&gt;
&lt;p&gt;在mac下你可以通过&lt;code&gt;brew install micropython&lt;/code&gt;安装micropython&lt;/p&gt;
&lt;h4&gt;import 模块&lt;/h4&gt;
&lt;p&gt;以超声波模块为例:&lt;a href="https://github.com/rsc1975/micropython-hcsr04"&gt;micropython-hcsr04&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在PYBFLASH目录下，拖入&lt;a href="https://github.com/rsc1975/micropython-hcsr04/blob/master/hcsr04.py"&gt;hcsr04.py&lt;/a&gt;，之后在便可使用它: &lt;code&gt;import hcsr04&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;其他话题&lt;/h1&gt;
&lt;h3&gt;中断(interrupts)&lt;/h3&gt;
&lt;p&gt;如果你想在pyboard中实现事件机制，可以使用硬件中断: &lt;a href="http://docs.micropython.org/en/latest/pyboard/pyboard/tutorial/switch.html"&gt;The Switch, callbacks and interrupts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中断回调的函数，需要注意内存&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# pyb.Pin(&amp;quot;X17&amp;quot;)是用户按钮&lt;/span&gt;
&lt;span class="n"&gt;extint&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pyb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ExtInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pyb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;X17&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;pyb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ExtInt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IRQ_FALLING&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pyb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PULL_UP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;多线程&lt;/h3&gt;
&lt;p&gt;如果你要用多线程(诸如模拟事件)，你需要先烧录threading版本的固件，之后你就可以食用&lt;code&gt;_thread&lt;/code&gt;模块 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;_thread&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myThread_A&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;thread A-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myThread_B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;thread B-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;thread B- Sleep 5s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;thread B-Wake up&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myThread_C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;thread C-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_new_thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myThread_A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_new_thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myThread_B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
&lt;span class="n"&gt;_thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_new_thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myThread_C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;优化&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;a cross-compiler and frozen bytecode, to have pre-compiled scripts that don't take any RAM (except for any dynamic objects they create)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;一些实用/有趣的项目&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/jeffmer/micropython-upyphone"&gt;micropython-upyphone&lt;/a&gt;: 基于 pyboard 和 sim800l的GSM电话&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dhylands/upy-examples"&gt;upy-examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/peterhinch/Micropython-scheduler"&gt;Micropython-scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/peterhinch/micropython-async"&gt;micropython-async&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/micropython/webrepl"&gt;webrepl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/MicroPython"&gt;wikipedia MicroPython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://micropython.org/"&gt;micropython.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/micropython/micropython"&gt;github micropython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.micropython.org/en/latest/pyboard/"&gt;micropython doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers"&gt;kickstarter micropython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/micropython/micropython-lib"&gt;github micropython-lib&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate><guid>tag:,2017-12-21:micropython-notes.html</guid><category>micropython</category></item><item><title>在树莓派中玩转Sense HAT</title><link>/rpi_sense_hat.html</link><description>&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/sense_hatfeb71968.png" /&gt;&lt;/p&gt;
&lt;p&gt;上图来自ESA(欧洲空间局)&lt;/p&gt;
&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;从&lt;a href="https://www.raspberrypi.org/products/sense-hat/"&gt;Sense HAT&lt;/a&gt;的产品介绍中,我们知道Sense HAT是Raspberry Pi的附加板，直接插到树莓派的针脚阵列上即可使用，十分方便&lt;/p&gt;
&lt;p&gt;Sense HAT为&lt;a href="https://astro-pi.org/"&gt;Astro Pi&lt;/a&gt;而生，它在2015年登上国际空间站，有兴趣的同学可以看&lt;a href="https://astro-pi.org/about/"&gt;这里&lt;/a&gt;,目前这个活动吸引了很多孩子的眼球，毕竟你写的代码可能跑在空间站里呢&lt;/p&gt;
&lt;p&gt;我上周入手了一块Sense HAT，它长这样:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/sense_hat18d0c89e.png" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，它有一块8x8的led阵列，值得一提的是它是RGB的，可以把它视为一个彩色像素屏。此外它还带有一个五个按钮的操纵杆，同时携带以下传感器:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;陀螺仪传感器&lt;/li&gt;
&lt;li&gt;加速度传感器&lt;/li&gt;
&lt;li&gt;磁传感器&lt;/li&gt;
&lt;li&gt;温度传感器&lt;/li&gt;
&lt;li&gt;气压传感器&lt;/li&gt;
&lt;li&gt;湿度传感器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本着自带电池的python精神，当然也是有一个python库来方便你使用这些硬件设备的:&lt;a href="http://pythonhosted.org/sense-hat/"&gt;Python module to control the Raspberry Pi Sense HAT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是不是有点激动！你再不用吭哧吭哧地逐个购买传感器，然后吭哧吭哧地去连线，还得担心引脚被占用而购买面包板，接好传感器，你又得吭哧吭哧地去网上逐个搜索驱动它们的代码，不出意外的话，许多地代码年久失修跑不起来，又或者系统地更新导致的不兼容...&lt;/p&gt;
&lt;p&gt;现在你一次性得到这么多与物理世界沟通的设备，而需要做的不过是把这块板子插入树莓派&lt;/p&gt;
&lt;h1&gt;上手&lt;/h1&gt;
&lt;p&gt;首先你当然需要一个可运行的树莓派，如果你是新手，可以参考我之前的文章:&lt;a href="http://blog.just4fun.site/raspberrypi-install-and-config.html"&gt;树莓派折腾笔记之系统安装与配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我用的是2016-05-27的版本(最新的版本特别不稳定，我当小白鼠也是当够了)&lt;/p&gt;
&lt;p&gt;如果你用的也是我这个版本，那么你的sense-hat不是最新的(默认是2.1.0)，你最好去更新以下它(截止到2017-05-20，sense-hat最新的版本是2.2.0)&lt;/p&gt;
&lt;h3&gt;更新python-sense-hat&lt;/h3&gt;
&lt;p&gt;直接更新:&lt;code&gt;sudo pip install sense-hat==2.2.0&lt;/code&gt;尽管也能安装成功，不过使用的时候会报错，系统依赖问题,你需要按照下边的做法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virtualenv env --system-site-packages &lt;span class="c1"&gt;#这样能使用系统已有的依赖，不然会报错&lt;/span&gt;
&lt;span class="nb"&gt;source&lt;/span&gt; env/bin/activate
pip install sense-hat&lt;span class="o"&gt;==&lt;/span&gt;2.2.0
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;连接硬件&lt;/h3&gt;
&lt;p&gt;连接硬件特简单,直接对着针脚插上去就行,如果你连外壳都买了，组装好应该和下边一样:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/sense_hat55f99856.png" /&gt;&lt;/p&gt;
&lt;p&gt;美美哒&lt;/p&gt;
&lt;h1&gt;跑起来&lt;/h1&gt;
&lt;p&gt;我们可以跟着起步教程来做:&lt;a href="https://www.raspberrypi.org/learning/getting-started-with-the-sense-hat/worksheet/"&gt;Getting Started with the Sense HAT&lt;/a&gt;，你可以现在网页上看模拟器的表现&lt;/p&gt;
&lt;p&gt;首先当然是&lt;code&gt;hello world&lt;/code&gt;啦&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sense_hat&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SenseHat&lt;/span&gt;
&lt;span class="n"&gt;sense&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SenseHat&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;sense&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show_message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hello world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在树莓派中运行上边的代码，led屏幕上将滑过&lt;code&gt;hello world&lt;/code&gt;，很像店面门口电子公告板上闪烁的: &lt;code&gt;春节快乐&lt;/code&gt;这种公告&lt;/p&gt;
&lt;p&gt;不过遗憾的是，并不能显示中文&lt;/p&gt;
&lt;h3&gt;其他传感器&lt;/h3&gt;
&lt;p&gt;其他传感器的用法,在&lt;a href="https://www.raspberrypi.org/learning/getting-started-with-the-sense-hat/worksheet/"&gt;Getting Started with the Sense HAT&lt;/a&gt;都有范例&lt;/p&gt;
&lt;p&gt;你也可以把&lt;a href="https://www.raspberrypi.org/learning/astro-pi-guide/"&gt;A Guide to Astro Pi&lt;/a&gt;当成学习传感器入口&lt;/p&gt;
&lt;h1&gt;跑个游戏玩&lt;/h1&gt;
&lt;p&gt;黑客门对像素游戏的痴迷可以追溯到计算机早期，《黑客：计算机革命的英雄》一书中提到的life就是有趣的像素游戏，我原本想在这个8*8的led阵列上做一个life，后来在&lt;a href="https://trinket.io/sense-hat"&gt;trinket.io&lt;/a&gt;已经有人做了不少有意思的游戏，于是决定先试玩它们&lt;/p&gt;
&lt;p&gt;flappy是我喜欢的一个游戏，恰好看到有人把它移植到sense hat里，就玩了下，很有意思&lt;/p&gt;
&lt;p&gt;我把代码放到gist上了,你可以直接从gist上拉取代码:&lt;code&gt;wget https://gist.githubusercontent.com/wwj718/81ba103c1e64c66c5bec3eb94cbfb062/raw/1a0a6547b5c9e059029d09c2df98057e2b5e7816/flappy_hat.py&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后运行它:&lt;code&gt;python flappy_hat.py&lt;/code&gt;&lt;/p&gt;
&lt;video src="http://olk8jbdzi.bkt.clouddn.com/sense_cut.mp4" autoplay controls="controls"&gt;&lt;/video&gt;

&lt;p&gt;哈哈 玩得开心&lt;/p&gt;
&lt;h1&gt;脑洞&lt;/h1&gt;
&lt;p&gt;我之前用树莓派和超声波传感器/震动传感器做了flappy（疯狂的小鸟）的体感版本&lt;/p&gt;
&lt;p&gt;如今我们有了sense hat要做体感游戏容易多了，它有陀螺仪传感器和加速度传感器 ，而且非常灵敏&lt;/p&gt;
&lt;p&gt;等之后闲下来慢慢玩&lt;/p&gt;
&lt;h3&gt;官方的有趣教程&lt;/h3&gt;
&lt;p&gt;树莓派官方网站有许多开脑洞的教程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.raspberrypi.org/learning/sense-hat-pong/worksheet/"&gt;Make a Pong clone for your Sense HAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.raspberrypi.org/learning/sense-hat-marble-maze/worksheet/"&gt;Sense Hat Marble Maze&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.raspberrypi.org/learning/pixel-pet/worksheet/"&gt;Interactive Pixel Pet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="ihttps://github.com/bennuttall/sense-hat-examples/blob/master/python/minecraft_colour.py"&gt;minecraft_colour&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.raspberrypi.org/learning/exploring-space-with-minecraft/worksheet2/"&gt;Displaying data from the Sense HAT in Minecraft&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.raspberrypi.org/learning/getting-started-with-the-sense-hat/worksheet/"&gt;Getting Started with the Sense HAT&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/RPi-Distro/python-sense-hat"&gt;python-sense-hat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.raspberrypi.org/learning/astro-pi-guide/"&gt;A Guide to Astro Pi&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.raspberrypi.org/products/sense-hat/"&gt;SENSE HAT&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://trinket.io/sense-hat"&gt;trinket.io&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate><guid>tag:,2017-05-14:rpi_sense_hat.html</guid><category>rpi</category></item><item><title>在blockly中构建语音识别/合成 积木块</title><link>/blockly-sound_recognition.html</link><description>&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/speech_block9f7d476a.png" /&gt;&lt;/p&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;近期在完善blockly4pi中AI的相关部分，语音和图像/视频流是常见的输入，语音的输入之前计划在硬件积木那边采集，之后流向树莓派，交由树莓派来处理，不过协议因此变得复杂许多，一番权衡之下，我们决定在浏览器里来处理多媒体输入&lt;/p&gt;
&lt;p&gt;我一直在关注浏览器中的webRTC和Web Speech，之前在几个项目中也接触过它们,这些接口现在越发强大了，而且浏览器的支持也在变好&lt;/p&gt;
&lt;h1&gt;Web Speech&lt;/h1&gt;
&lt;p&gt;HTML5中和Web Speech相关的API有两类, 一类是"语音合成(Speech Synthesis)"，一类是"语音识别(Speech Recognition)",无论哪种,使用起来都非常简单. &lt;/p&gt;
&lt;h3&gt;语音合成&lt;/h3&gt;
&lt;p&gt;之前语音合成我一直用百度语音来做，效果还不错，不过多了一层网络请求.&lt;/p&gt;
&lt;p&gt;Chrome 浏览器在版本25之后开始支持这一特性，效果非常棒.你可以调出你的控制台,让浏览器说: '你好,世界',像下边这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;utterThis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SpeechSynthesisUtterance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;你好，世界！&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;speechSynthesis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;speak&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;utterThis&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;神奇的是，竟然没有用到云服务，完全在本地完成!&lt;/p&gt;
&lt;h3&gt;语音识别&lt;/h3&gt;
&lt;p&gt;相比于语音合成，语音识别还有些坑。&lt;/p&gt;
&lt;p&gt;我们先来说下它的简单用法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;newRecognition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;webkitSpeechRecognition&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nx"&gt;newRecognition&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;onresult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;newRecognition&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上边短短的几行，你就完成了浏览器调用麦克风，等待语音输入到结果输出的完成流程&lt;/p&gt;
&lt;p&gt;如果你只是想拿到输出结果的内容，可以这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;newRecognition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;webkitSpeechRecognition&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;//newRecognition.continuous = false;&lt;/span&gt;
&lt;span class="nx"&gt;newRecognition&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;onresult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//console.log(event);&lt;/span&gt;
        &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;results&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="nx"&gt;transcript&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;transcript&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;transcript&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;newRecognition&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;识别结果比较理想&lt;/p&gt;
&lt;h4&gt;坑&lt;/h4&gt;
&lt;p&gt;有个恼人的坑是，识别开始后，浏览器有时候一直在等待输入，而无法返回识别结果（可能是墙的原因），这种情况时常发生，而且在各个平台下(mac/windows)下都是如此&lt;/p&gt;
&lt;p&gt;不过在chrome的开发版(canary)中一切正常,我的当前版本号是:&lt;code&gt;60.0.3099.0（正式版本）canary （64 位&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;包装成blockly积木块&lt;/h1&gt;
&lt;p&gt;为了将其纳入到blockly4pi体系中，我们需要将Web Speech包装为blockly积木块&lt;/p&gt;
&lt;p&gt;语音合成部分比较简单,在积木中接受用户输入，传到api中即可，@dsl已经完成了这个工作&lt;/p&gt;
&lt;p&gt;语音识别部分会比较麻烦，在上边的语音识别示例代码里，我们看到对语音的识别结果出现在&lt;code&gt;onresult&lt;/code&gt;事件回调的函数里，这样一来控制流就不是线性的了(哈哈 在js中这才是常态)，如何在blockly中表达变达这种控制流，是个值得思考的问题&lt;/p&gt;
&lt;p&gt;熟悉js的同学会觉得思路上不难，可要在blockly中表达也没有很容易，首先得熟悉blockly的表达习惯和api,有些部分涉及比较高级的api&lt;/p&gt;
&lt;p&gt;这个问题webduino团队给出了漂亮的解答，我们稍后对其&lt;a href="https://github.com/webduinoio/webduino-blockly"&gt;源码&lt;/a&gt;做个分析&lt;/p&gt;
&lt;h3&gt;源码分析&lt;/h3&gt;
&lt;p&gt;熟悉blockly的小伙伴，很轻松能定位到目标积木块的源码(我们只关注sound_recognition块，其他块相对简单)&lt;/p&gt;
&lt;p&gt;在注释中我们找到了积木块的生成方式：&lt;a href="https://blockly-demo.appspot.com/static/demos/blockfactory/index.html#shuqaz"&gt;sound_recognition blockfactory&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/sound_blockfccbdea4.png" /&gt;&lt;/p&gt;
&lt;p&gt;积木外观由以下代码定义:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Blockly.Blocks[&amp;#39;sound_recognition&amp;#39;] = {
  init: function() {
    this.appendDummyInput()
        .appendField(&amp;quot;開始語音辨識 ( Chrome 限定，不支援 iOS )&amp;quot;);
    this.appendDummyInput()
        .appendField(&amp;quot;辨識語言：&amp;quot;)
        .appendField(new Blockly.FieldDropdown([[&amp;quot;中文&amp;quot;,&amp;quot;cmn-Hant-TW&amp;quot;], [&amp;quot;English&amp;quot;,&amp;quot;en-US&amp;quot;]]), &amp;quot;lang_&amp;quot;)
        .appendField(&amp;quot;    即時辨識：&amp;quot;)
        .appendField(new Blockly.FieldDropdown([[&amp;quot;on&amp;quot;,&amp;quot;on&amp;quot;], [&amp;quot;off&amp;quot;,&amp;quot;off&amp;quot;]]), &amp;quot;interimResults_&amp;quot;)
        .appendField(&amp;quot;( 行動裝置勾選 off )&amp;quot;);
    this.appendStatementInput(&amp;quot;recognition_&amp;quot;);
    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setTooltip(&amp;#39;&amp;#39;);
    this.setHelpUrl(&amp;#39;&amp;#39;);
  }
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(以js为例)拿到积木中的用户的输入很简单:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Blockly.JavaScript[&amp;#39;sound_recognition&amp;#39;] = function(block) {
  var dropdown_lang_ = block.getFieldValue(&amp;#39;lang_&amp;#39;);
  var dropdown_interimresults_ = block.getFieldValue(&amp;#39;interimResults_&amp;#39;);
  var statements_recognition_ = Blockly.JavaScript.statementToCode(block, &amp;#39;recognition_&amp;#39;);
  // TODO: Assemble JavaScript into code variable.
  var code = &amp;#39;...;\n&amp;#39;;
  return code;
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;statements_recognition_&lt;/code&gt;值得留意&lt;/p&gt;
&lt;p&gt;至此整个积木块已经完成，只剩下最后也最核心的问题了，sound_recognition是如何来generate出代码的，上边提到的回调的问题也是在这里处理&lt;/p&gt;
&lt;p&gt;直接上代码更直观些: &lt;a href="https://github.com/webduinoio/webduino-blockly/blob/19e40f0108e72dbd08628705a1e4fad9c3ccab7e/generators/webduino.js#L1727"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;抛开辅助性的代码，我们看到最核心的部分是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &amp;#39;    window._recognition.onresult = async function(event,result) {\n&amp;#39; +
    &amp;#39;      result = {};\n&amp;#39; +
    &amp;#39;      result.resultLength = event.results.length-1;\n&amp;#39; +
    &amp;#39;      result.resultTranscript = event.results[result.resultLength][0].transcript;\n&amp;#39; +
    &amp;#39;      if(event.results[result.resultLength].isFinal===&amp;#39; + inter1 + &amp;#39;){\n&amp;#39; +
    &amp;#39;        console.log(result.resultTranscript);\n&amp;#39; +
    &amp;#39;        &amp;#39; + statements_recognition_ +
    &amp;#39;        &amp;#39; + consoleFinal1 +
    &amp;#39;      }else if(event.results[result.resultLength].isFinal===&amp;#39; + inter2 + &amp;#39;){\n&amp;#39; +
    &amp;#39;        &amp;#39; + consoleFinal2 +
    &amp;#39;      }\n&amp;#39; +
    &amp;#39;    };\n&amp;#39; +
    &amp;#39;    window._recognition.start();\n&amp;#39; +
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;特别注意&lt;code&gt;statements_recognition_&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;顺便吐个槽，尽管code的拼接极尽排版的工整，但读起来还是不舒服，用es6的模版字符串来写会好看很多&lt;/p&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://javascript.ruanyifeng.com/htmlapi/webspeech.html"&gt;Web Speech&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/webduinoio/webduino-blockly"&gt;webduino-blockly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Fri, 12 May 2017 00:00:00 +0000</pubDate><guid>tag:,2017-05-12:blockly-sound_recognition.html</guid><category>rpi</category></item><item><title>u盘程序自启</title><link>/blockly4pi_codetest_u_disk.html</link><description>&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;依然是折腾我的blockly4pi项目的时候，顺路折腾的东西，感觉比较有趣，可能在一些好玩的场合能用到，分享出来&lt;/p&gt;
&lt;p&gt;题目有点噱头,实际上u盘程序不是自行启动，而是系统中有它的内应，这不是一个病毒程序: ) 不过你依然可以用它做些好玩的事情，甚至闹剧，这些就取决于想象力啦，18岁以下儿童请在家长陪同下观看( 逃:) )&lt;/p&gt;
&lt;p&gt;在blockly4pi中，树莓派与李老师的硬件积木采用无线(目前是wifi)的方式连接，树莓派与blockly前端页面(电脑)的连接也是无线.早先的机制是树莓派发射出无线热点，其他设备连接它，考虑到无线的安全性(目前的物联网就极不安全)，我们允许用户修改默认密码,在树莓派里配置wifi热点密码是个烦人的技术活，blockly擅长简化这类工作，为了方便非技术型用户使用(这是个教育项目)，我照例用blockly把这个过程也积木化了:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/blockly_wifi01d48051.png" /&gt;&lt;/p&gt;
&lt;p&gt;但是依然存在一些问题&lt;/p&gt;
&lt;h1&gt;问题描述&lt;/h1&gt;
&lt;p&gt;首先是树莓派模拟出来的热点不是标准的wifi协议,原因是树莓派3内置的网卡不支持. 因为协议不标准,硬件积木连接树莓派时，可能会出现连接失败的情况&lt;/p&gt;
&lt;p&gt;要解决这个问题，可以采用市面主流的usb网卡来发射热点，但需要手动编译hostapd，打上驱动的补丁，比较烦人&lt;/p&gt;
&lt;p&gt;而我们不想放弃无线连接的方案(至于不采用蓝牙和xbee的原因之后有机会再说)，于是我们想到的策略是硬件积木当热点。为了简化网络，我们决定区分调试和生产环境，在调试环境中使用websocket来实时做实验;而部署运行时，则采用u盘作为中介，放弃无线传输程序以换取稳定性和简洁&lt;/p&gt;
&lt;h1&gt;思路&lt;/h1&gt;
&lt;p&gt;采用u盘来传递blockly生成的程序最初是@TG主意，@TG是我现在的老板（学信息安全出身），我最初不确定这个思路是否行得通，我第一反应是这特么是个病毒：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"u盘插入电脑，立即运行其中的目标程序"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@TG说他学生时代玩这些比较熟，技术层面应该没问题，不过他也表示基本是在windows下折腾,当时windows漏洞多，至于我们用的是linux(raspbian)，可行性还有待评估&lt;/p&gt;
&lt;p&gt;我当天做了下试验，果真可行，思路上其实很容易:首先树莓派是我们自己的，上边跑什么进程，完全可自行决定,那在里边安排一个内应帮忙开门就是了(哈哈，监守自盗的守护进程)，监听u盘mount事件，然后找到挂载上来的u盘里的目标程序(python脚本)，将它run起来就好了&lt;/p&gt;
&lt;p&gt;我想到&lt;a href="https://github.com/gorakhargosh/watchdog"&gt;watchdog&lt;/a&gt;之类的工具,试了一下，有几个坑:首先文档糟糕，能找到的文档，基本只是介绍监控一个目录的变化，没有对mount的监控，当然有一些fork分支(pydica-watchdog)试图去做了(我们后边再说)，其中一个不能忍的地方时，事件会被随机通知一或两次，完全摸不着头脑&lt;/p&gt;
&lt;p&gt;于是我决定自己来写，在linux中一切皆文件，这样一来即便我对底层系统事件不熟也无所谓，挂载的u盘不过是新增个的目录而已啊! &lt;/p&gt;
&lt;p&gt;说干就干！&lt;/p&gt;
&lt;h1&gt;动手&lt;/h1&gt;
&lt;p&gt;喜欢直接读代码的老司机这时候可能要发话了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;talk is cheap show me the code (废话少说，放码过来)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好好好，这就甩你一脸源码:&lt;a href="https://gist.github.com/wwj718/095c661a11c6f55ce64332f0fb91be52"&gt;udisk_watch.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主体程序非常简单:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sleep 3s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;watching /media/pi/ ...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;udisk_exists&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/media/pi/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;udisk_exists&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;can not find u disk&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;media_pi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listdir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/media/pi/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;u_root&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;media_pi&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
              &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;u_root&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;newest_codetest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_newest_codetest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u_root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;udisk_codetest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newest_codetest&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;udisk_codetest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;can not find the codetest(.*).py in the u disk&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="k"&gt;continue&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;find  the codetest(.*).py in the u disk&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;run_it&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;udisk_codetest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每隔3秒扫描一遍&lt;code&gt;/media/pi/&lt;/code&gt;,如果有新的u盘挂载过来，则会出现类似&lt;code&gt;/media/pi/u_disk1&lt;/code&gt;这类目录，这个目录我们视为u盘根目录，之后在u盘根目录里通过&lt;code&gt;get_newest_codetest&lt;/code&gt;函数寻找最新的目标程序(我们将目标程序命名类似codetest.py)，&lt;code&gt;get_newest_codetest&lt;/code&gt;的实现如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_newest_codetest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u_root&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;    在u盘第一层目录里找&lt;/span&gt;
&lt;span class="sd"&gt;    需要获取最新的文件的原因是，学生可能会拖动多个文件进去&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;udisk_dir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/media/pi/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;u_root&lt;/span&gt;
    &lt;span class="n"&gt;codetestlist&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listdir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;udisk_dir&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;codetest&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;codetestlist&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;udisk_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;codetestlist&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;newest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;codetestlist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st_mtime&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;newest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;newest&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里似乎有点啰嗦，直接找codetest.py不就好了.&lt;/p&gt;
&lt;p&gt;补充下之所以需要寻找最新的以codetest开头的目标程序，是因为我们的blockly4pi平台会在用户拼搭好程序积木后，生成对应的程序，浏览器有个机制，会根据因为你下载了多次同名程序而导致新的程序被自动重命名,类似:codetest(1).py、codetest(2).py这样，，尽管我们可以让用户自行处理(自己命名为codetest.py放到u盘里)，到考虑到非技术用户的学习成本和出错概率(输入法半角符号之类的坑)，我们决定在程序中功能自行处理，用户无需对生成的程序进行处理，一股脑拖到u盘里，然后把u盘查到树莓派上，我们的程序就会自行寻找最新的程序并运行它&lt;/p&gt;
&lt;p&gt;另外值得一提的是，我们的blockly4pi web 操作台是个纯前端页面(这意味着它可以无处不在)，托管在CDN，至于如何自动为用户生成并下载codetest.py（大家知道纯前端无法用js生成并下载python脚本文件到本地）(ps:h5有新的接口，参考文末更新)，用到了类似微服务的概念，有一个无状态的服务等待blockly页面的请求，然后将请求数据包裹成脚本文件，并在用户不知情的情况下，下载下来，如此一来用户自始至终不需要离开我们的实验台&lt;/p&gt;
&lt;p&gt;回到我们的话题，通过上边的函数我们找到了最新的程序，接下来就是如何运行它,这里的关键是如何只运行一次（这是我弃用watchmedo(watchdog)的原因，它会莫名其妙地多次运行，不能忍）。这个问题有许多解决方案，本质上都是为程序添加记忆功能（状态）. 我们采用扫描目录的机制，木已成舟，就继续沿着这条路，简单粗暴的做法是，在进程里存下已运行脚本的指纹(md5), 通过比对它是否发生变化决定是否运行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_file_md5&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;md5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hashlib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;md5&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hexdigest&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;file_md5&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;md5&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;md5&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run_it&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filepath&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# todo:重构为log&lt;/span&gt;
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;last_md5_udisk_codetest&lt;/span&gt;
    &lt;span class="n"&gt;current_file_md5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;generate_file_md5&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filepath&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_file_md5&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;last_md5_udisk_codetest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;copyfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filepath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;PI_CODETEST&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;pkill&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-f&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;codetest&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;running!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/usr/bin/python {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PI_CODETEST&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#会自己退出?&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;run complate!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;last_md5_udisk_codetest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_file_md5&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;全局变量&lt;code&gt;last_md5_udisk_codetest&lt;/code&gt;记录着上次运行的文件的指纹，&lt;code&gt;generate_file_md5&lt;/code&gt;函数用来采集文件指纹&lt;/p&gt;
&lt;p&gt;以上 : )&lt;/p&gt;
&lt;p&gt;完整的代码看&lt;a href="https://gist.github.com/wwj718/095c661a11c6f55ce64332f0fb91be52"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;一些想法延伸&lt;/h1&gt;
&lt;p&gt;如果用supervisor来管理上述的脚本，可以轻松实现开机自启&lt;/p&gt;
&lt;p&gt;如果使用pyinstaller编译上述脚本（需要调整，建议参考文末的项目，项目作者是个老司机，对不同的操作系统十分熟悉），你可以把它变为一个不依赖于python的exe文件,跑在所有的windows上，至于你想干什么，取决于想象力 :)&lt;/p&gt;
&lt;h1&gt;附录:pydica-watchdog&lt;/h1&gt;
&lt;p&gt;监控mount事件，可以使用watchdog的这个衍生版:pydica-watchdog&lt;/p&gt;
&lt;p&gt;这个项目年久失修，直接安装会报依赖库错误(argh)，你需要这样安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install pydica-watchdog
pip install &lt;span class="nv"&gt;argh&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;0.25
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之后像watchdog一样使用它:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;watchmount shell-command   --patterns&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*.py;&amp;quot;&lt;/span&gt;  --recursive  --command&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;echo &amp;quot;${watch_src_path}”&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同watchdog一样，它也有间歇性执行两次的问题:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/watchdogc53ff8ef.png" /&gt;&lt;/p&gt;
&lt;h3&gt;更新(2017.5.9)&lt;/h3&gt;
&lt;p&gt;我之前提到纯前端不能生成python脚本有误，h5有这样的接口，(就是说纯前端静态页面就可以做到)，上周末在&lt;a href="http://blocklyduino.github.io/BlocklyDuino/blockly/apps/blocklyduino/index.html"&gt;BlocklyDuino&lt;/a&gt;看到这个机制&lt;/p&gt;
&lt;p&gt;核心库是&lt;a href="https://github.com/eligrey/FileSaver.js"&gt;FileSaver.js&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>tag:,2017-05-01:blockly4pi_codetest_u_disk.html</guid><category>rpi</category></item><item><title>进程间通信一例</title><link>/ipc_on_blockly4pi.html</link><description>&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/blockly4pi391b0c97.png" /&gt;&lt;/p&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;我最近在折腾blockly4pi，这是一个教育项目，致力于将编程带入到基础教育，通过使用&lt;a href="https://developers.google.com/blockly/"&gt;blockly&lt;/a&gt;,我们将原子操作封装为积木块，学生只需要操作积木块就能做到程序能做到的事&lt;/p&gt;
&lt;p&gt;已经封装为积木的原子操作，除了blockly提供的基本编程要素(循环、条件、逻辑等)，我们还积木化了虚拟角色的操作以及硬件操作。&lt;/p&gt;
&lt;p&gt;硬件的积木化不只是对硬件的操作积木化，硬件本身也被设计为积木&lt;/p&gt;
&lt;p&gt;用户通过拖拽web试验平台拖拽积木块，将生成对应程序代码(我目前选择生成python，其实js也是很棒的选择)，之后这些代码在树莓派里运行以操控硬件。&lt;/p&gt;
&lt;p&gt;我们的硬件积木与树莓派之间采用wifi通信，硬件积木自然是李老师做的(对李老师有兴趣的可以参考我之前的文章),目前的原型机便是文章开头的那张图&lt;/p&gt;
&lt;p&gt;我们之前为了省心采用了类似http(实际是socket)的通信机制(请求-答复-中断)来做树莓派和积木节点之间的通信，虽然架构简单，不过带来了一个麻烦，实时性不高的问题,近期重新调整为长链接&lt;/p&gt;
&lt;h1&gt;问题&lt;/h1&gt;
&lt;p&gt;我们最初放弃长链接的一个原因是：对硬件积木的操作指令是用户生成的，用户每次在web界面搭建好积木点击运行，树莓派里新起python进程。如此一来长连接就不能建立在动态生成的脚本里。因为脚本是动态执行的，随时可能因为用户新的提交而中断（执行新的）. &lt;/p&gt;
&lt;h1&gt;思路&lt;/h1&gt;
&lt;p&gt;于是我想到用ipc(进程间通信)来解决这个问题: 在树莓派中使用两个进程来做这件事（分别以进程一和进程二表示）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户在web页面拖拽积木块生成代码，之后代码作为脚本运行在树莓派中，此为进程一，它是动态的 （为了保证清晰和教学方便，只允许在单次提交中使用多线程，不允许多次脚本并行）&lt;/li&gt;
&lt;li&gt;进程二运行在后台(不中断),负责与硬件节点保持长连接，该进程同时作为server，等待进程二传递的控制硬件节点的消息,同时将消息传递给硬件积木&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说进程二是用户动态生成的脚本与硬件积木的中间人，使用这个中间人的目的是保持长链接不中断&lt;/p&gt;
&lt;p&gt;从数据的视角来看，进程一只是个管道，它只负责传递消息，管道本是静态的，我们使用载荷来承载变化的消息&lt;/p&gt;
&lt;h1&gt;实现&lt;/h1&gt;
&lt;p&gt;一旦进入实现部分，岔路就多了，尽管可能都通往罗马，但有些路荆棘遍布，有些路一马平川，如何选择，感觉有时候比分析重要，这可能是工程问题中偏艺术的一环&lt;/p&gt;
&lt;p&gt;就我而言，在不熟悉的领域，我便好走人多的一条路，即便迷路的话，指路人也多&lt;/p&gt;
&lt;p&gt;尽管进程间通信的方法很多，我选择Socket(套接口),Socket为目前Linux上最为广泛使用的一种的进程间通信机制，与其他的Linux通信机制不同之处在于除了它可用于单机内的进程间通信以外，还可用于不同机器之间的进程间通信&lt;/p&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;p&gt;考虑到这部分可能对其他同学也有帮助，我将这部分的具体实现放过来(只展示原理)&lt;/p&gt;
&lt;p&gt;进程二为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c1"&gt;# encoding: utf-8&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;socket&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;os.path&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;settings&lt;/span&gt;

&lt;span class="n"&gt;sockfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;./communicate.sock&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;sockfile&lt;/span&gt; &lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;sockfile&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Opening socket...&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AF_UNIX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfile&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;host_li&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;settings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HOST_LI&lt;/span&gt;&lt;span class="c1"&gt;# 硬件积木的host，从setting里读&lt;/span&gt;
&lt;span class="n"&gt;port_li&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;settings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PORT_LI&lt;/span&gt;
&lt;span class="c1"&gt;# 关于为了硬件积木当server，有空再谈&lt;/span&gt;
&lt;span class="c1"&gt;# todo : 连接失败处理机制&lt;/span&gt;

&lt;span class="n"&gt;socket2li&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="n"&gt;socket2li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;host_li&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port_li&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Listening...&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send_message2server_li&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;socket2li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sendall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket2li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;datagram&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;datagram&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;exit&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;send_message2server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;datagram&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
  &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进程一与进程二通信部分为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send_message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;s01d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AF_UNIX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;./communicate.sock&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sendall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从这里我们可以看到，我们实际把中断进行了转移，把与远程主机的中断移到了本地。如此一来延迟变得非常小&lt;/p&gt;
&lt;h1&gt;扫尾&lt;/h1&gt;
&lt;p&gt;细心的小伙伴可能会看到，我们这里没有做掉线重连、启动顺序、错误处理之类的机制，这些保证健壮性的工作我放到源码里，有兴趣的同学可以自行阅读&lt;/p&gt;
&lt;p&gt;需要说明的是&lt;code&gt;等待机器上线后连接&lt;/code&gt;部分的代码我用的是《python network programming cookbook》中&lt;a href="https://github.com/lovexiaov/learn-python/blob/master/python-network-programming-cookbook/sorce_code/chapter3/3_3_wait_for_remote_service.py"&gt;第三章的源码&lt;/a&gt;，周末逛书店看到这部分代码很漂亮，就直接拿过来用，替换了我之前自己写的&lt;/p&gt;
&lt;h1&gt;FAQ&lt;/h1&gt;
&lt;h3&gt;进程二中的server可以使用web server吗&lt;/h3&gt;
&lt;p&gt;可以的，不采用的原因是web server比socket啰嗦太多&lt;/p&gt;
&lt;h3&gt;为何不用zeromq&lt;/h3&gt;
&lt;p&gt;我其实偏好zeromq,关于zeromq的优点，我之前笔记里又记录:&lt;a href="http://blog.just4fun.site/mq-note.html"&gt;消息队列中间件学习笔记&lt;/a&gt; ,zeromq 是个野心勃勃而欣欣向荣的项目&lt;/p&gt;
&lt;p&gt;没用它的主要原因是，硬件开发者，包李老师，偏好用socket&lt;/p&gt;
&lt;p&gt;尽管我可以在进程二与硬件积木中使用socket连接(迁就硬件这边)，在进程一与进程二之间使用zeromq，不过获得的好处并不明显，还导致了不一致，感觉不划算&lt;/p&gt;
&lt;h4&gt;2017-04-29补充&lt;/h4&gt;
&lt;p&gt;目前能想到使用zeromq的一个场景是:多个用户能一起用浏览器来控制我们的硬件积木(我们在此只关注通信部分，其他方面暂不关注) ,也就是说需要1-N连接(1是server，N是client),直接使用REQUEST/RESPONSE模型就行 &lt;/p&gt;
&lt;p&gt;这里给个示例代码(照抄&lt;a href="http://www.firefoxbug.com/index.php/archives/2755/"&gt;这里&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;zmq&lt;/span&gt;  

&lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  

&lt;span class="c1"&gt;#  Socket to talk to server  &lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Connecting to hello world server...&amp;quot;&lt;/span&gt;  
&lt;span class="n"&gt;socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tcp://localhost:5555&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  

&lt;span class="c1"&gt;#  Do 10 requests, waiting each time for a response  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Sending request &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;  
    &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  

    &lt;span class="c1"&gt;#  Get the reply.  &lt;/span&gt;
    &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Received reply &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;服务端:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;zmq&lt;/span&gt;  
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;  

&lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="n"&gt;socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zmq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;REP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tcp://*:5555&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
    &lt;span class="c1"&gt;#  Wait for next request from client  &lt;/span&gt;
    &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Received request: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; 

    &lt;span class="c1"&gt;#  Do some &amp;#39;work&amp;#39;  &lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;#   Do some &amp;#39;work&amp;#39;  &lt;/span&gt;

    &lt;span class="c1"&gt;#  Send reply back to client  &lt;/span&gt;
    &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;World&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;client可以在server没有启动的时候上线（不会报错），只要服务端上线就不会丢消息,如此一来启动问题变得十分轻松，不必保证server先上线&lt;/p&gt;
&lt;p&gt;其次client可以有多个，server能同时处理它们，不会引起混乱&lt;/p&gt;
&lt;p&gt;单是以上两点就省下我们许多工作&lt;/p&gt;
&lt;h3&gt;下一步打算如何改进&lt;/h3&gt;
&lt;p&gt;使用websocket，目前已经在开发环境里用了，具体原因之后有机会说&lt;/p&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A"&gt;wikipedia https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97"&gt;Unix域套接字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/developerworks/cn/linux/l-socket-ipc/"&gt;在 Linux 上实现基于 Socket 的多进程实时通信&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/11597284/how-do-i-create-a-python-socket-server-that-listens-on-a-file-descriptor"&gt;How do I create a Python socket server that listens on a file descriptor?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/6920858/interprocess-communication-in-python"&gt;interprocess communication in python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate><guid>tag:,2017-04-28:ipc_on_blockly4pi.html</guid><category>rpi</category></item><item><title>openbot之自然语言解析器</title><link>/openbot-natural-language-parser.html</link><description>&lt;blockquote&gt;
&lt;p&gt;行程才是目的，顿悟在每日的实践中 --《UNIX设编程艺术》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;openbot&lt;/h1&gt;
&lt;p&gt;openbot是我的业余项目，对NLP和AI的兴趣由来已久，想通过造轮子的方式来学习&lt;/p&gt;
&lt;p&gt;我是api.ai的忠实用户，也使用wit.ai（给这个项目的client提交过源码）。国内的yige.ai也很棒。openbot的web/sdk接口模仿着它们设计&lt;/p&gt;
&lt;p&gt;openbot最初作为&lt;a href="https://github.com/wwj718/deepThought"&gt;deepThought&lt;/a&gt;的衍生项目，相关思路可以参考：&lt;a href="https://github.com/wwj718/deepThought#衍生计划"&gt;deepThought#衍生计划&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后来觉得我的兴趣更多在架构，我日常接触的更多的也是架构，想把它变为一个通用的框架：这个框架提供通用的webapp，对外提供restful api，也提供各个语言的sdk以便开发者集成，目前完成了python sdk，nodejs的正在编写&lt;/p&gt;
&lt;p&gt;近期在看《Unix编程艺术》，13.4部分在谈论emacs的设计哲学，作者把emacs视为一个框架，作者说到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当编制一个框架时，牢记分离原则：框架是机制，尽可能少地包含策略...尽可能多地将行为分解到使用框架的模块中去&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我之前的架构简图如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/openbotda2fa65a.png" /&gt;&lt;/p&gt;
&lt;p&gt;openbot致力于将webapp和sdk做得开箱可用，而nlu可插拔，不限制实现策略，只要满足相关约定，即可插入到框架中对最终用户提供nlp服务,在结构图中，我以chatterbot作为bot server为例&lt;/p&gt;
&lt;p&gt;openbot项目近期没有开源，朋友的创业公司打算用它，如果之后合适，我会将其开源。&lt;/p&gt;
&lt;h1&gt;语法解析&lt;/h1&gt;
&lt;p&gt;轮子哥@vczh有句话在技术圈很有名&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序员的三大浪漫是编译原理，图形学和操作系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译原理确实一个有趣的话题，仅其中涉及的词法分析和语法分析就已十分迷人&lt;/p&gt;
&lt;p&gt;相较于解析编程语言（python程序员的入门资料可以参考&lt;a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p18_tokenizing_text.html"&gt;字符串令牌解析&lt;/a&gt;），我对解析自然语言的兴趣更大些，一方面来自对人工智能的兴趣，另一方面来自一直关注的分析哲学流派，他们把大多哲学问题处理为语言问题，分析哲学阵营的路德维希.维特根斯坦有句名言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;语言的极限便是世界的极限   --《逻辑哲学论》 5.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天的nlp领域同大多涉及智能的领域一样，基于统计/大数据。&lt;/p&gt;
&lt;h1&gt;&lt;a href="https://github.com/Kitt-AI/parsetron"&gt;parsetron&lt;/a&gt;&lt;/h1&gt;
&lt;h3&gt;缘起&lt;/h3&gt;
&lt;p&gt;我在&lt;a href="http://blog.just4fun.site/rpi-siri-close-light.html"&gt;嘿 Siri 关灯&lt;/a&gt;里提到我需要一个自然语言解析器，我准备使用yige.ai来替代Siri，以实现跨平台使用。我又想把它运行在本地&lt;/p&gt;
&lt;p&gt;《嘿 Siri 关灯》是典型的nlp+硬件控制的案例（你可能想到扎尔伯格的&lt;a href="https://m.toutiao.com/i6366879371965235714/?tt_from=weixin_moments&amp;amp;utm_campaign=client_share&amp;amp;app=news_article&amp;amp;utm_source=weixin_moments&amp;amp;iid=6814510930&amp;amp;utm_medium=toutiao_android&amp;amp;wxshare_count=2&amp;amp;pbid=31547628651&amp;amp;from=timeline&amp;amp;isappinstalled=0"&gt;Jarvis&lt;/a&gt;），在我的场景中（使用自然语言驱动硬件），自然语言处理模块并不需要很强大，对话的模式也很简单，多是&lt;code&gt;嘿siri，把灯打开/把空调打开/把风扇打开&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Kitt.ai开放的&lt;a href="Parsetron"&gt;https://github.com/Kitt-AI/parsetron&lt;/a&gt;是个不错的选择，小巧而实用，可以一言不合就修改源码。&lt;/p&gt;
&lt;h3&gt;关于&lt;/h3&gt;
&lt;p&gt;parsetron是个非常有趣的项目，来自Kitt.ai&lt;/p&gt;
&lt;p&gt;parsetron将自己定位在一个足够小的领域（诸如我手头的硬件控制），这样需要处理的语言模式比较单一，绕开了nlp领域会遇到的大多复杂问题(许多问题在学术圈也依旧困难，遑论工程)&lt;/p&gt;
&lt;p&gt;parsetron是个典型的通过降低选择复杂度，让项目变得健壮而实用的案例，按照《UNIX编程艺术》的说法：通过选择合适的目标能有效降低复杂度&lt;/p&gt;
&lt;p&gt;人工智能在一个细分领域可能做得很好，可如果我们一开始提高人们的期望，把它定位在通用型AI，往往容易给人"人工智障"的感觉，目前好用的bot多是找了一个具体的小场景，这也符合UNIX哲学里的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do one thing and do well&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文关注如何使用parsetron，之后有时间再分析&lt;a href="http://parsetron.kitt.ai/en/latest/quickstart.html#how-it-works"&gt;原理&lt;/a&gt;和&lt;a href="https://github.com/Kitt-AI/parsetron"&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;入门&lt;/h3&gt;
&lt;p&gt;安装很简单&lt;code&gt;pip install parsetron&lt;/code&gt;,目前只支持python2，parsetron没有任何外部依赖&lt;/p&gt;
&lt;p&gt;&lt;a href="http://parsetron.kitt.ai/en/latest/quickstart.html#simple-example"&gt;文档&lt;/a&gt;里的demo是非常好的入门案例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;parsetron&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Regex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OneOrMore&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Grammar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RobustParser&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LightGrammar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Grammar&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;change&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;flash&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;set&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;blink&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;light&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;top&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;middle&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;bottom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Regex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;r&amp;#39;(red|yellow|blue|orange|purple|...)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;times&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;once&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;twice&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;three times&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Regex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;r&amp;#39;\d+ times&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;one_parse&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;light&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;
    &lt;span class="n"&gt;GOAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;OneOrMore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;one_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RobustParser&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;LightGrammar&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
        &lt;span class="n"&gt;sents&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;set my top light to red&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;set my top light to red and change middle light to yellow&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;set my top light to red and change middle light to yellow and flash bottom light twice in blue&amp;quot;&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;sent&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sents&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;one_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;red&amp;#39;&lt;/span&gt;

            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;sent&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;parse tree:&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;parse result:&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行&lt;code&gt;LightGrammar.test()&lt;/code&gt;得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;set my top light to red&amp;quot;
parse tree:
(GOAL
  (one_parse
    (action &amp;quot;set&amp;quot;)
    (light &amp;quot;top&amp;quot;)
    (color &amp;quot;red&amp;quot;)
  )
)

parse result:
{
  &amp;quot;one_parse&amp;quot;: [
    {
      &amp;quot;one_parse&amp;quot;: [
        &amp;quot;set&amp;quot;,
        &amp;quot;top&amp;quot;,
        &amp;quot;red&amp;quot;
      ],
      &amp;quot;light_span_&amp;quot;: [
        2,
        3
      ],
      &amp;quot;action_span_&amp;quot;: [
        0,
        1
      ],
      &amp;quot;light&amp;quot;: &amp;quot;top&amp;quot;,
      &amp;quot;color_span_&amp;quot;: [
        5,
        6
      ],
      &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
      &amp;quot;action&amp;quot;: &amp;quot;set&amp;quot;,
      &amp;quot;one_parse_span_&amp;quot;: [
        0,
        6
      ]
    }
  ],
  &amp;quot;GOAL&amp;quot;: [
    [
      &amp;quot;set&amp;quot;,
      &amp;quot;top&amp;quot;,
      &amp;quot;red&amp;quot;
    ]
  ]
}

&amp;quot;set my top light to red and change middle light to yellow&amp;quot;
parse tree:
(GOAL
  (one_parse
    (action &amp;quot;set&amp;quot;)
    (light &amp;quot;top&amp;quot;)
    (color &amp;quot;red&amp;quot;)
  )
  (one_parse
    (action &amp;quot;change&amp;quot;)
    (light &amp;quot;middle&amp;quot;)
    (color &amp;quot;yellow&amp;quot;)
  )
)

parse result:
{
  &amp;quot;one_parse&amp;quot;: [
    {
      &amp;quot;one_parse&amp;quot;: [
        &amp;quot;set&amp;quot;,
        &amp;quot;top&amp;quot;,
        &amp;quot;red&amp;quot;
      ],
      &amp;quot;light_span_&amp;quot;: [
        2,
        3
      ],
      &amp;quot;action_span_&amp;quot;: [
        0,
        1
      ],
      &amp;quot;light&amp;quot;: &amp;quot;top&amp;quot;,
      &amp;quot;color_span_&amp;quot;: [
        5,
        6
      ],
      &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
      &amp;quot;action&amp;quot;: &amp;quot;set&amp;quot;,
      &amp;quot;one_parse_span_&amp;quot;: [
        0,
        6
      ]
    },
    {
      &amp;quot;one_parse&amp;quot;: [
        &amp;quot;change&amp;quot;,
        &amp;quot;middle&amp;quot;,
        &amp;quot;yellow&amp;quot;
      ],
      &amp;quot;light_span_&amp;quot;: [
        8,
        9
      ],
      &amp;quot;action_span_&amp;quot;: [
        7,
        8
      ],
      &amp;quot;light&amp;quot;: &amp;quot;middle&amp;quot;,
      &amp;quot;color_span_&amp;quot;: [
        11,
        12
      ],
      &amp;quot;color&amp;quot;: &amp;quot;yellow&amp;quot;,
      &amp;quot;action&amp;quot;: &amp;quot;change&amp;quot;,
      &amp;quot;one_parse_span_&amp;quot;: [
        7,
        12
      ]
    }
  ],
  &amp;quot;GOAL&amp;quot;: [
    [
      &amp;quot;set&amp;quot;,
      &amp;quot;top&amp;quot;,
      &amp;quot;red&amp;quot;
    ],
    [
      &amp;quot;change&amp;quot;,
      &amp;quot;middle&amp;quot;,
      &amp;quot;yellow&amp;quot;
    ]
  ]
}

&amp;quot;set my top light to red and change middle light to yellow and flash bottom light twice in blue&amp;quot;
parse tree:
(GOAL
  (one_parse
    (action &amp;quot;set&amp;quot;)
    (light &amp;quot;top&amp;quot;)
    (color &amp;quot;red&amp;quot;)
  )
  (one_parse
    (action &amp;quot;change&amp;quot;)
    (light &amp;quot;middle&amp;quot;)
    (color &amp;quot;yellow&amp;quot;)
  )
  (one_parse
    (action &amp;quot;flash&amp;quot;)
    (light &amp;quot;bottom&amp;quot;)
    (Optional(times)
      (times
        (Set(three times|twice|once) &amp;quot;twice&amp;quot;)
      )
    )
    (color &amp;quot;blue&amp;quot;)
  )
)

parse result:
{
  &amp;quot;one_parse&amp;quot;: [
    {
      &amp;quot;one_parse&amp;quot;: [
        &amp;quot;set&amp;quot;,
        &amp;quot;top&amp;quot;,
        &amp;quot;red&amp;quot;
      ],
      &amp;quot;light_span_&amp;quot;: [
        2,
        3
      ],
      &amp;quot;action_span_&amp;quot;: [
        0,
        1
      ],
      &amp;quot;light&amp;quot;: &amp;quot;top&amp;quot;,
      &amp;quot;color_span_&amp;quot;: [
        5,
        6
      ],
      &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
      &amp;quot;action&amp;quot;: &amp;quot;set&amp;quot;,
      &amp;quot;one_parse_span_&amp;quot;: [
        0,
        6
      ]
    },
    {
      &amp;quot;one_parse&amp;quot;: [
        &amp;quot;change&amp;quot;,
        &amp;quot;middle&amp;quot;,
        &amp;quot;yellow&amp;quot;
      ],
      &amp;quot;light_span_&amp;quot;: [
        8,
        9
      ],
      &amp;quot;action_span_&amp;quot;: [
        7,
        8
      ],
      &amp;quot;light&amp;quot;: &amp;quot;middle&amp;quot;,
      &amp;quot;color_span_&amp;quot;: [
        11,
        12
      ],
      &amp;quot;color&amp;quot;: &amp;quot;yellow&amp;quot;,
      &amp;quot;action&amp;quot;: &amp;quot;change&amp;quot;,
      &amp;quot;one_parse_span_&amp;quot;: [
        7,
        12
      ]
    },
    {
      &amp;quot;one_parse&amp;quot;: [
        &amp;quot;flash&amp;quot;,
        &amp;quot;bottom&amp;quot;,
        &amp;quot;twice&amp;quot;,
        &amp;quot;blue&amp;quot;
      ],
      &amp;quot;color_span_&amp;quot;: [
        18,
        19
      ],
      &amp;quot;light_span_&amp;quot;: [
        14,
        15
      ],
      &amp;quot;action_span_&amp;quot;: [
        13,
        14
      ],
      &amp;quot;light&amp;quot;: &amp;quot;bottom&amp;quot;,
      &amp;quot;Optional(times)&amp;quot;: &amp;quot;twice&amp;quot;,
      &amp;quot;times&amp;quot;: &amp;quot;twice&amp;quot;,
      &amp;quot;Optional(times)_span_&amp;quot;: [
        16,
        17
      ],
      &amp;quot;times_span_&amp;quot;: [
        16,
        17
      ],
      &amp;quot;Set(three times|twice|once)&amp;quot;: &amp;quot;twice&amp;quot;,
      &amp;quot;action&amp;quot;: &amp;quot;flash&amp;quot;,
      &amp;quot;Set(three times|twice|once)_span_&amp;quot;: [
        16,
        17
      ],
      &amp;quot;one_parse_span_&amp;quot;: [
        13,
        19
      ],
      &amp;quot;color&amp;quot;: &amp;quot;blue&amp;quot;
    }
  ],
  &amp;quot;GOAL&amp;quot;: [
    [
      &amp;quot;set&amp;quot;,
      &amp;quot;top&amp;quot;,
      &amp;quot;red&amp;quot;
    ],
    [
      &amp;quot;change&amp;quot;,
      &amp;quot;middle&amp;quot;,
      &amp;quot;yellow&amp;quot;
    ],
    [
      &amp;quot;flash&amp;quot;,
      &amp;quot;bottom&amp;quot;,
      &amp;quot;twice&amp;quot;,
      &amp;quot;blue&amp;quot;
    ]
  ]
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;非常漂亮！&lt;/p&gt;
&lt;p&gt;更完整的例子可以参考 &lt;a href="http://parsetron.kitt.ai/en/latest/quickstart.html#complex-example"&gt;Complex Example&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;It is mainly used to convert natural language command to executable API calls (e.g., “set my bedroom light to red” –&amp;gt; set_light('bedroom', [255, 0, 0]))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;parsetron的典型使用场景是将自然语言转变为api调用，实际是将非结构话的自然语言，解析为结构化的数据，进而调用api。&lt;/p&gt;
&lt;p&gt;作者给出了一些&lt;a href="http://parsetron.kitt.ai/en/latest/quickstart.html#what-it-is"&gt;典型使用场景&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;诸如使用自然语言控制你的智能灯泡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;give me something romantic&lt;/li&gt;
&lt;li&gt;my living room light is too dark&lt;/li&gt;
&lt;li&gt;change bedroom light to sky blue&lt;/li&gt;
&lt;li&gt;blink living room light twice in red color&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及控制你的微波炉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;defrost this chicken please, the weight is 4 pounds&lt;/li&gt;
&lt;li&gt;heat up the pizza for 2 minutes 20 seconds&lt;/li&gt;
&lt;li&gt;warm up the milk for 1 minute&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者给出了这类需求的通用解决方案：从自然语言命令中提取关键信息，以帮助开发人员调用API来控制智能设备。由此完成了自然语言指令到传统程序的映射&lt;/p&gt;
&lt;p&gt;作者进一步分析说传统的方法是编写一系列规则，如正则表达式，这些规则难以维护和扩展。而采用编译原理中的词法/语法解析。不但学习曲线很高，且解析器输出通常是树结构，对我们的任务没有直接的帮助&lt;/p&gt;
&lt;p&gt;我在&lt;a href="https://github.com/wwj718/deepThought"&gt;deepThought&lt;/a&gt;的目标里写过&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构造通用的解析工具，将自然语言解析为结构化信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这点与parsetron不谋而合，parsetron对我而言是作为bot server的理想实现，用于解析硬件指令&lt;/p&gt;
&lt;p&gt;其实目前Siri也具有这个功能（需要hack，而且比较繁琐），我在《嘿 Siri 关灯》主要就用到这个功能。&lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;parsetron暂不支持中文，项目的todo中有支持unicode的计划，不过项目一年来似乎没更新了，我fork了这个项目，近期试着为它增加中文支持&lt;/p&gt;
&lt;h1&gt;Pyparsing&lt;/h1&gt;
&lt;p&gt;Parsetron的文档里写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Parsetron is inspired by pyparsing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们顺路了解一下&lt;a href="https://pyparsing.wikispaces.com/"&gt;pyparsing&lt;/a&gt;，顾名思义，Pyparsing是python实现的解析器。&lt;/p&gt;
&lt;h3&gt;入门&lt;/h3&gt;
&lt;p&gt;简单做个入门了解。以解析"Hello, World!"为例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyparsing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alphas&lt;/span&gt;
&lt;span class="n"&gt;greet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Word&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;alphas&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Word&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;alphas&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;!&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;# &amp;lt;-- grammar defined here&lt;/span&gt;
&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;-&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;greet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parseString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出为：&lt;code&gt;Hello, World! -&amp;gt; ['Hello', ',', 'World', '!']&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上边的greet可以解析任何具有以下模式的句子： &lt;code&gt;&amp;lt;salutation&amp;gt;, &amp;lt;addressee&amp;gt;!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更多案例和使用方法参考:&lt;a href="https://pyparsing.wikispaces.com/Examples"&gt;Examples&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;支持中文&lt;/h3&gt;
&lt;p&gt;值得一提的是pyparsing支持python3和unicode，这对我们处理中文会有大帮助。我们来做个试验：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# python3&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyparsing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alphas&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;CharsNotIn&lt;/span&gt;
&lt;span class="n"&gt;greet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CharsNotIn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;,!&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;CharsNotIn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;,!&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;!&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;# &amp;lt;-- grammar defined here&lt;/span&gt;
&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;你好, 世界!&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;-&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;greet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parseString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出为 ： &lt;code&gt;好, 世界! -&amp;gt; ['你好', ',', ' 世界', '!']&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个解决方案可行，但比较丑陋，如何在pyparsing使用unicode，可以自行google&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate><guid>tag:,2016-12-26:openbot-natural-language-parser.html</guid><category>tools</category></item><item><title>嘿 Siri 关灯</title><link>/rpi-siri-close-light.html</link><description>&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/siri17469bd4.png" /&gt;&lt;/p&gt;
&lt;h1&gt;引言&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;你在南方的艳阳里大雪纷飞,我在北方的寒夜里四季如春&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;马頔的这句歌词，道尽南方人过冬的艰辛。在没有暖气的南方，过冬基本靠抖腿和一身正气&lt;/p&gt;
&lt;p&gt;我们以高中诗词鉴赏的套路来剖析下词作，"你在南方的艳阳里大雪纷飞"当然不是直白地描述一场太阳雪,艺术要有含蓄美。这句话实际上说的是"你"在南方灯如暖阳的房间里，忘穿秋裤，冻得像雪地里呆呆的兔子（由此可见这个灯是白炽灯而不是节能灯，节能灯如白月光而不似暖阳）&lt;/p&gt;
&lt;p&gt;如果你有兴趣深挖，会进一步坚定艳阳指的就是灯。小如洞穴的房间、灯与影子，不由让人想到柏拉图的洞穴理论，作者进而感慨现实世界的不真实性，于是有后边的"穷极一生做不完一场梦"&lt;/p&gt;
&lt;p&gt;至于如果题目问"你"指的是谁，你最好不要答前女友，其他随意，以免勾起阅卷老师伤感的回忆，给你个悲伤的分数&lt;/p&gt;
&lt;p&gt;在灯如暖阳床如霜的南方夜晚，你刚看完《汇编语言从入门到放弃》，准备起床关灯睡觉，却对被子依依不舍。这时你想：要是对着Siri说一声&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嘿siri，宝宝困了帮我关灯么么哒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;便可睡觉该是多美的场景&lt;/p&gt;
&lt;p&gt;又或者 圣诞夜你和你的小女朋友在被窝里讨论拉普拉斯变换或是傅里叶变换，可窗帘没拉，灯太亮影响发挥。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嘿Siri关灯并闭上眼睛&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们撸起袖子来实现它&lt;/p&gt;
&lt;h1&gt;思路&lt;/h1&gt;
&lt;p&gt;我不建议你给房间换一个智能灯泡，也不打算向你推销一套年底特价智能家居解决方案，我们延续之前的思路(&lt;a href="http://blog.just4fun.site/raspberrypi-lirc.html"&gt;用树莓派给家用电器加上智能&lt;/a&gt;)，尽量用非入侵的方式来解决问题，不去破坏和替换现有的设备&lt;/p&gt;
&lt;p&gt;于是我们就提出这样一个问题：如何在不改变现有灯泡特性、电路结构和开关特性的情况下，来关灯？&lt;/p&gt;
&lt;p&gt;能想到的方案似乎只有模拟人手的动作，以机械的方式来按下开关&lt;/p&gt;
&lt;p&gt;"舵机"就是我们的首选了&lt;/p&gt;
&lt;p&gt;剩下的就是如何躺在床上控制舵机来关灯，与硬件世界打交道，树莓派是我偏好的工具。树莓派控制舵机不成问题，至于如何用手机控制树莓派，我也在此前的文章中论述过&lt;/p&gt;
&lt;p&gt;不过本文将采用更酷的方式，你将无需编程，通过拖曳积木化的模块，就可以搭建出关灯机器人，然后通过siri控制这个机器人,如此一来你可以用自然语言的方式给siri发送关灯命令&lt;/p&gt;
&lt;p&gt;这个方案拓展开，我们几乎可以控制所有的按键式开关&lt;/p&gt;
&lt;p&gt;自然语言处理这部分Siri帮我们做了，之后有机会我们自己来实现，听起来有点像最近怒刷各种技术社区的&lt;a href="https://m.toutiao.com/i6366879371965235714/?tt_from=weixin_moments&amp;amp;utm_campaign=client_share&amp;amp;app=news_article&amp;amp;utm_source=weixin_moments&amp;amp;iid=6814510930&amp;amp;utm_medium=toutiao_android&amp;amp;wxshare_count=2&amp;amp;pbid=31547628651&amp;amp;from=timeline&amp;amp;isappinstalled=0"&gt;Jarvis&lt;/a&gt; --扎尔伯格用人工智能控制家居的项目&lt;/p&gt;
&lt;h1&gt;准备工作&lt;/h1&gt;
&lt;h3&gt;硬件部分&lt;/h3&gt;
&lt;p&gt;硬件部分包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树莓派&lt;/li&gt;
&lt;li&gt;舵机&lt;/li&gt;
&lt;li&gt;长导线&lt;/li&gt;
&lt;li&gt;移动电源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/siri56e654b0.png" /&gt;&lt;/p&gt;
&lt;p&gt;组件不多，考虑到电灯开关的位置一般齐胸，而树莓派和移动电源(供电)放在地上，所以你需要三根长导线，而不是普通的杜邦线，和往常一样，长导线这种东西都是从万能的@李老师的万能的实验室里要来的,感谢@李老师一直以来的助攻&lt;/p&gt;
&lt;p&gt;下边我们对各个部分做个简单介绍：&lt;/p&gt;
&lt;h4&gt;树莓派&lt;/h4&gt;
&lt;p&gt;关于树莓派，可以参考我此前的文章:&lt;a href="http://blog.just4fun.site/raspberrypi-install-and-config.html"&gt;树莓派折腾笔记之系统安装与配置&lt;/a&gt;.入门新手会遇到的问题我基本都列出了&lt;/p&gt;
&lt;p&gt;我也翻译了一份&lt;a href="https://github.com/wwj718/awesome-raspberry-pi-zh"&gt;树莓派(Raspberry Pi)资源大全中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;供大家玩耍时参考&lt;/p&gt;
&lt;h4&gt;舵机&lt;/h4&gt;
&lt;p&gt;我买的是淘宝上的SG90 9g舵机，价格6块多,关于舵机的控制原理比较麻烦，李老师跟我描述过，我听个大概，不过不影响，去网上抄段程序修修改改，封装为黑盒函数基本能用，有空在细看这块&lt;/p&gt;
&lt;p&gt;简单介绍下舵机上的几根线:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红色：电压&lt;/li&gt;
&lt;li&gt;粽色：地线&lt;/li&gt;
&lt;li&gt;橙色：信号线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我把信号线接到18号引脚(BCM) ，查看gpio图：&lt;code&gt;gpio readall&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;李老师&lt;/h4&gt;
&lt;p&gt;顺便也介绍些李老师.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;李老师其实不是我的老师,我毕业后才认识他，我从李老师这边学到很多硬件知识，从传道解惑的角度来说，李老师确是我的老师&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;李老师南大博士毕业后，在大学执教，他博士阶段读的是图像识别，但他是个彻头彻尾的硬件黑客&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;李老师的实验室黑科技齐全，哆啦A梦口袋一般，有求必应&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;李老师常说的话有这样一种模式："没事没事，xx功能的电子设备买不到也没事，我们自己画，等印刷完，你过来取". 我们有个有趣的项目，硬件部分都是李老师画的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迄今 只有一次例外: 有一回李老师在论述分布式节点的连接策略时，我有点开小差，状态类似"一人虽听之 一心以为有鸿鹄将至 思援弓缴而射之". 我突然想要一个无线开关来控制我那不够智能的油汀，以便于用树莓派控制它。而李老师也和往常一样，一边论述一边离题，岔到其他他感兴趣的话题:这回是关于如何把无线模块画得更小，当他兴致勃勃地分享这个灵光一现时，我不合时宜地提出说我想要一个无线开关，能不能用继电器、开关外壳和无线模块，外加画个板子集成它们，李老师以一种给你糖吃别打岔的样子，说这个淘宝上有卖的，app都自带的，你去买一个，抓包hack它就能编程了。于是李老师继续谈论他画板子的布线方案&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;李老师实验室的四轴飞行器，除了飞行器是自己做的，遥控手柄也是自己画的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大家感受一下&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/lilaoshi397d1e4f.png" /&gt;&lt;/p&gt;
&lt;p&gt;让我们想到那句感人的话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;情之所钟，虽丑不嫌&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感觉哪里不对 ……&lt;/p&gt;
&lt;h3&gt;组装硬件&lt;/h3&gt;
&lt;p&gt;硬件部分的组装很容易，直接上效果图&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/siri4cc6a938.png" /&gt;&lt;/p&gt;
&lt;p&gt;接下来让我们用双面胶把舵机贴到开关边上，舵机转动即可关灯&lt;/p&gt;
&lt;h1&gt;软件部分&lt;/h1&gt;
&lt;p&gt;按照一般的套路，此处应该从舵机的驱动程序写起，加上通讯模块，接着写一些胶水程序黏合它们，组成实现完整的功能&lt;/p&gt;
&lt;p&gt;软件部分如开篇所说，这次我想试试不通过编程的方式来完成这个工作. 仅仅通过拖拽功能模块，我们就能拼出功能的机器人,这样可以让更多的人参与进来(当然包括哪些在玩王者荣耀的小学生)&lt;/p&gt;
&lt;p&gt;我已经完成了积木式的控制平台,硬件驱动全部封装为积木块(让每个人实现一次硬件驱动未免无聊)，拖曳即可，支持几乎完备的编程要素，可以实现丰富的功能&lt;/p&gt;
&lt;p&gt;我们来拖曳模块完成任务，Siri的请求本身被我封装为模块&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/siri.gif" /&gt;&lt;/p&gt;
&lt;p&gt;完成后，程序为: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/siri15bab0b4.png" /&gt;&lt;/p&gt;
&lt;p&gt;至于对原理有兴趣的geek小伙伴，在之后的文章里，我们再来讲解细节实现,实际hack了Siri&lt;/p&gt;
&lt;h1&gt;效果演示&lt;/h1&gt;
&lt;p&gt;点击"运行程序"，程序就会在树莓派中运行（开机自启）,我们做个演示&lt;/p&gt;
&lt;video src="http://ocfy0072v.bkt.clouddn.com/siri-%E5%85%B3%E7%81%AF-1.mp4" controls="controls"&gt;&lt;/video&gt;

&lt;h1&gt;自然语言&lt;/h1&gt;
&lt;p&gt;因为Siri本身具有处理自然语言的能力，我们可以用许多说法来关灯&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/siri05dcb491.png" /&gt;&lt;/p&gt;
&lt;h1&gt;todo&lt;/h1&gt;
&lt;p&gt;当前的自然语言处理(NLU)用得到了Siri，下一个版本想试试&lt;a href="http://www.yige.ai/"&gt;yige.ai&lt;/a&gt;,然后把它植入到微信中，这样可以跨平台使用它&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Sat, 24 Dec 2016 00:00:00 +0000</pubDate><guid>tag:,2016-12-24:rpi-siri-close-light.html</guid><category>rpi</category></item><item><title>周末、填坑与树莓派资源大全</title><link>/awesome-raspberry-pi-zh.html</link><description>&lt;h3&gt;周末&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pi_lmdc5109614.png" /&gt;&lt;/p&gt;
&lt;p&gt;难得的晴天，午睡足，醒来快三点，下午骑车闲逛，到老门东，一路骑来，风光满眼&lt;/p&gt;
&lt;p&gt;途闻桂香，想到-dumb-在《秋望》里写到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;桂子天香渐满廊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻出原句，再读，依然觉得大好：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;前調
    秋望
老去身閑與世忘。罷裁矮紙倚昏黃。孤光一出千山暗，小立人間萬木涼。  新涕淚，古蒼茫。片時相對已恩長。秋風葉上清商起，桂子天香漸滿廊。
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;填坑&lt;/h3&gt;
&lt;p&gt;到老门东星巴克，选了个二楼靠窗位置,可见斜檐、屋顶、明城墙&lt;/p&gt;
&lt;p&gt;准备坐上半天，来填近来挖的坑&lt;/p&gt;
&lt;p&gt;先把完整填完的坑，放上来&lt;/p&gt;
&lt;h3&gt;树莓派资源大全&lt;/h3&gt;
&lt;p&gt;近来折腾了几个好玩的东西，与树莓派有关，也陆续写了几篇文章，收到不少邮件，大家还蛮喜欢的。开心&lt;/p&gt;
&lt;p&gt;折腾树莓派过程中看到不少国内外好玩的项目，我喜欢收集整理有趣的东西，也喜欢归档到博客和github。&lt;/p&gt;
&lt;p&gt;前端时间看到国外有人整理了&lt;a href="https://github.com/thibmaek/awesome-raspberry-pi"&gt;awesome-raspberry-pi&lt;/a&gt;，决定翻译为中文。之后我还打算在树莓派上折腾图形化编程、ai和自动驾驶之类的东西，会长期和树莓派打交道，所以将长期维护这个树莓派资源列表&lt;/p&gt;
&lt;p&gt;如果你用树莓派做了什么好玩的东西，并且愿意分享出来，欢迎把你的项目加入到资源列表里 ：）&lt;/p&gt;
&lt;p&gt;具体的资源大全戳这里：&lt;a href="https://github.com/wwj718/awesome-raspberry-pi-zh"&gt;wwj718/awesome-raspberry-pi-zh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;期待你的PR : )&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate><guid>tag:,2016-10-30:awesome-raspberry-pi-zh.html</guid><category>tools</category></item><item><title>基于树莓派和Tensowflow的物体识别-speaker</title><link>/raspberrypi-tensowflow-robot-speaker.html</link><description>&lt;p&gt;接上篇文章:&lt;a href="http://blog.just4fun.site/raspberrypi-tensowflow-robot.html"&gt;基于树莓派和Tensowflow的物体识别-brain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上篇文章里我们用tensorflow的inception模型为&lt;code&gt;树莓派探险者&lt;/code&gt;添加智能（它的大脑（brain））。这篇文章里我们给他添加外设，使其"说"出物体的名称，我们将使其成为speaker&lt;/p&gt;
&lt;p&gt;ps：之所以叫树莓派探险者是它的行为很像一个初入地球的外星机器人，对周遭事物充满好奇，试图弄清看到的每个物体是什么（代码的实现是超声波测距+拍照+tensorflow图像识别）&lt;/p&gt;
&lt;h1&gt;目标&lt;/h1&gt;
&lt;p&gt;我们将使树莓派探险者用中文说出看到的物体的名字，诸如&lt;code&gt;这是一个橘子&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;任务&lt;/h1&gt;
&lt;p&gt;为了实现这个目标我们有几件事要做。&lt;/p&gt;
&lt;p&gt;tensorflow的inception模型识别完物体，将输出5个最为贴近的物体的英文名称。我们选取得分最高的物体，将其名称翻译为中文，之后用蓝牙音箱输出：&lt;code&gt;这是一个xxx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;实际上是以下两项任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;英汉翻译&lt;/li&gt;
&lt;li&gt;中文文字转语音&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;解决方案&lt;/h1&gt;
&lt;p&gt;完成以上任务，有两种典型的方案，一种使用云服务，一种使用本地软件&lt;/p&gt;
&lt;h3&gt;云服务&lt;/h3&gt;
&lt;p&gt;使用云服务，我们可以轻松完成以上两项任务，英汉翻译使用：&lt;a href="https://github.com/translate/translate"&gt;translate&lt;/a&gt;, 这是一个python库，直接pip安装就行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# pip install translate&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;translate&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Translator&lt;/span&gt;
&lt;span class="n"&gt;translator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Translator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from_lang&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;en&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;to_lang&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;zh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;translation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;translator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;translate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;umbrella&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;translation&lt;/span&gt; &lt;span class="c1"&gt;#雨伞&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;中文文字转语音可以使用&lt;a href="http://yuyin.baidu.com/tts/"&gt;百度语音合成&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;本地软件&lt;/h3&gt;
&lt;p&gt;为了提高响应速度和可控性，使其减少对网络的依赖（有些环境并没有网络），也许我们更倾向使用本地软件&lt;/p&gt;
&lt;p&gt;下面分别论述如何在不依赖网络的情况下使用本地软件来完成翻译和文字转语音的任务&lt;/p&gt;
&lt;p&gt;英汉翻译我们选择: &lt;code&gt;sdcv&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo  apt-get install sdcv
mkdir -p ~/.stardict/dic # 之后把字典下载解压到这个目录里
sdcv orange #查询单词 orange
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之后我们用正则提取出其中的名词选项，选择最靠前的（这个策略没有认真考虑过）&lt;/p&gt;
&lt;p&gt;至于字典的下载可以到这里：&lt;a href="http://abloz.com/huzheng/stardict-dic/zh_CN/"&gt;zh_CN 简体中文词典&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我下了三个字典：朗道英汉字典5.0、KDic11万英汉词典、牛津简明英汉袖珍辞典&lt;/p&gt;
&lt;p&gt;朗道英汉字典5.0内容详尽，牛津简明英汉袖珍辞典简单清晰&lt;/p&gt;
&lt;p&gt;我偏好后者&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;下一个任务是中文文字转语音，树莓派机器人原作者Lukas使用&lt;a href="http://www.festvox.org/flite/"&gt;Flite&lt;/a&gt;来做文字转语音。Flite是一个小型、快速的TTS系统，是著名的语音合成系统festival的C版本，可用于嵌入式系统&lt;/p&gt;
&lt;p&gt;可惜这个工具不支持中文，我决定采用:&lt;a href="https://github.com/hgneng/ekho"&gt;ekho&lt;/a&gt;来做文字转语音的工作，项目介绍在:&lt;a href="http://www.eguidedog.net/cn/ekho_cn.php"&gt;Ekho(余音) - 中文语音合成软件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他可选的工具还有eSpeak,安装和使用都简单。&lt;code&gt;espeak -vzh "你好"&lt;/code&gt;，发音比较机械&lt;/p&gt;
&lt;h1&gt;todo&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;增加看图说话功能（Show and Tell: image captioning open sourced in TensorFlow）&lt;/li&gt;
&lt;li&gt;语音识别（pocketsphinx）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/zouxy09/article/details/7942784"&gt;PocketSphinx语音识别系统的编译、安装和使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jlinux/blog/blob/master/posts/voice-control.md"&gt;voice-control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate><guid>tag:,2016-10-25:raspberrypi-tensowflow-robot-speaker.html</guid><category>tools</category></item><item><title>基于树莓派和Tensowflow的物体识别-brain</title><link>/raspberrypi-tensowflow-robot.html</link><description>&lt;p&gt;近来这篇文章很火：&lt;a href="https://www.oreilly.com/learning/how-to-build-a-robot-that-sees-with-100-and-tensorflow"&gt;How to build a robot that “sees” with $100 and TensorFlow&lt;/a&gt; （作者是Lukas，CrowdFlower创始人）
，中文译本为《如何用100美金和Tensowflow来造一个能"看"东西的机器人》，公众号们纷纷转载&lt;/p&gt;
&lt;p&gt;文章读来饶有趣味，里边涉及的技术大多接触过，都不难，遂决定动手实现它&lt;/p&gt;
&lt;p&gt;要实现整个项目，我手头还缺小车底盘，我们先来实现这个项目的核心部分：用树莓派和Tensowflow的识别现实世界的物体。日后有空再加上小车&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/orange94aa0771.png" /&gt;&lt;/p&gt;
&lt;p&gt;随手把桌子上同事给的橘子拍下来，之后我们试着让树莓派认出它&lt;/p&gt;
&lt;h1&gt;任务描述&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://www.oreilly.com/learning/how-to-build-a-robot-that-sees-with-100-and-tensorflow"&gt;How to build a robot that “sees” with $100 and TensorFlow&lt;/a&gt; 已经把要做的是事说清楚了&lt;/p&gt;
&lt;p&gt;物体识别是近来机器学习领域的热点之一。对于识别人脸或是区分猫狗这件事上，计算机已经胸有成竹，而在更大的图片集中识别一个指定的物体还是人工智能领域的“圣杯”，不过近年也有很大进展&lt;/p&gt;
&lt;p&gt;我们将造一个能自己识别物体的机器人（不需要云服务）&lt;/p&gt;
&lt;h1&gt;工具介绍&lt;/h1&gt;
&lt;h3&gt;树莓派&lt;/h3&gt;
&lt;p&gt;树莓派（Raspberry Pi）是一款基于Linux的单板机电脑，它只有巴掌大小，却有惊人的计算能力，你可以把它当做一台普通电脑。&lt;/p&gt;
&lt;p&gt;树莓派的使命是制作一套启发孩子的电脑，降低孩子们试错的成本&lt;/p&gt;
&lt;p&gt;树莓派最新的版本是树莓派3,较前一代树莓派2，树莓派3的处理器升级为了64位的博通BCM2837，并首次加入了Wi-Fi无线网络及蓝牙功能。加量不加价&lt;/p&gt;
&lt;h3&gt;TensorFlow&lt;/h3&gt;
&lt;p&gt;TensorFlow是一个由"Google大脑"团队的研究人员开发的机器学习库，Google遵循Apache License 2.0将其开源。该系统可以被用于语音识别、图片识别等多个领域&lt;/p&gt;
&lt;p&gt;在这个项目中我们主要用到一个叫做&lt;a href="https://github.com/tensorflow/models/tree/master/inception"&gt;inception&lt;/a&gt;的模型（基于ImageNet数据集）。它可以完成物体识别，我们直接使用预训练好的模型。训练模型可是个费时费力的工作&lt;/p&gt;
&lt;p&gt;你把智能当黑盒使用的时候，并不需要有那么多偷懒的负罪感啦（哈哈  我还是有一点）&lt;/p&gt;
&lt;p&gt;电气时代来临的时候，变革社会的除了那些发电的人，那些懂得使用电力去改造传统行业，创造新的行业的人，也许对社会的变革更为深刻。尽管他们可能连卡诺循环都不知道，甚至不知如何将水蒸汽中的动能转换为功，进而驱动电机发电&lt;/p&gt;
&lt;h4&gt;ImageNet数据集&lt;/h4&gt;
&lt;p&gt;这个数据集包含约120万张训练图像、5万张验证图像和10万张测试图像，分为1000个不同的类别，用于机器学习中训练图像识别系统&lt;/p&gt;
&lt;h1&gt;准备工作&lt;/h1&gt;
&lt;p&gt;我们先准备好树莓派,我用的是安装了&lt;a href="https://downloads.raspberrypi.org/raspbian/images/raspbian-2016-05-31/"&gt;raspbian-2016-05-31&lt;/a&gt;版本的树莓派3代（使用其他版本应该也没问题），关于树莓派的相关配置可以参考我之前的文章：&lt;a href="http://blog.just4fun.site/raspberrypi-install-and-config.html"&gt;树莓派折腾笔记之系统安装与配置&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;安装Tensowflow&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://www.oreilly.com/learning/how-to-build-a-robot-that-sees-with-100-and-tensorflow"&gt;How to build a robot that “sees” with $100 and TensorFlow&lt;/a&gt; 这篇文章里，作者采用的是TensorFlow提供的makefile命令，在树莓派中本地编译，这一步骤花费了作者几个小时。不过好处是一步到位。安装完后可以直接运行：&lt;code&gt;tensorflow/contrib/pi_examples/label_image/gen/bin/label_image&lt;/code&gt;来识别物体&lt;/p&gt;
&lt;p&gt;我不打算编译安装，除了过程费事，还需要在安装的几个小时里提心吊胆，深怕某个依赖问题导致前功尽弃，重新编译。 我在手动编译opencv的时候就曾备受折磨&lt;/p&gt;
&lt;h3&gt;我的安装过程&lt;/h3&gt;
&lt;p&gt;我们先安装已经适合树莓派的Tensowflow，这种工作，肯定有人做过，github一搜果不其然：&lt;a href="https://github.com/samjabrahams/tensorflow-on-raspberry-pi"&gt;tensorflow-on-raspberry-pi&lt;/a&gt;。我们开始安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget https://github.com/samjabrahams/tensorflow-on-raspberry-pi/raw/master/bin/tensorflow-0.9.0-cp27-none-linux_armv7l.whl
sudo pip install tensorflow-0.9.0-cp27-none-linux_armv7l.whl  #这一步会安装其他依赖，如果太慢，可以用-i参数，使用豆瓣源
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装过程很快，也就喝杯茶时间，过程十分流畅&lt;/p&gt;
&lt;p&gt;Tensowflow安装完成，我们开始加载模型,安装过程参考这里:&lt;a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/pi_examples"&gt;pi_examples&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir  ~/tf
cd /usr/local/lib/python2.7/dist-packages/tensorflow/models/image/imagenet
python classify_image.py --model_dir ~/tf/imagenet #--model_dir 指定模型数据存放的目录
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成后我们来测试下是否正常&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python /usr/local/lib/python2.7/dist-packages/tensorflow/models/image/imagenet/classify_image.py  --model_dir ~/tf/imagenet
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果是如下输出则一切就绪：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca (score = 0.89233)
indri, indris, Indri indri, Indri brevicaudatus (score = 0.00859)
lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens (score = 0.00264)
custard apple (score = 0.00141)
earthstar (score = 0.00107)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;我们来试一下我的伞（拍于办公室）：&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/sandfa6b51c.png" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python /usr/local/lib/python2.7/dist-packages/tensorflow/models/image/imagenet/classify_image.py  --model_dir ~/tf/imagenet --image_file /tmp/test.jpg  # 图片需是jpg格式
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出为&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/san47120afa.png" /&gt;&lt;/p&gt;
&lt;p&gt;程序会给出5个可能的物体，得分最高的是雨伞，识别的很准确&lt;/p&gt;
&lt;p&gt;我们接着给它看一张橘子的图片：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/orange94aa0771.png" /&gt;&lt;/p&gt;
&lt;p&gt;输出为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lemon (score = 0.72036)
orange (score = 0.16516)
spaghetti squash (score = 0.01571)
butternut squash (score = 0.00304)
ocarina, sweet potato (score = 0.00298)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它认为最大的可能是柠檬，橘子和柠檬确实很相似&lt;/p&gt;
&lt;p&gt;如果你想自己来训练你的模型，可以参考googleblog上的这篇文章:&lt;a href="https://research.googleblog.com/2016/03/train-your-own-image-classifier-with.html"&gt;Train your own image classifier with Inception in TensorFlow&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;优化&lt;/h1&gt;
&lt;p&gt;目前物体识别的性能不高，需要等一会儿，Lukas的机器人很有趣，它每次拍下照片，开始计算的时候会说&lt;code&gt;I'm thinking&lt;/code&gt;。延时得很自然，机器也确实是在“思考”&lt;/p&gt;
&lt;p&gt;关于如何提高运算速度，以下是几个可能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用GPU来计算。树莓派支持GPU运算，不过&lt;a href="https://github.com/samjabrahams/tensorflow-on-raspberry-pi"&gt;tensorflow-on-raspberry-pi&lt;/a&gt;目前没有GPU版本的whl，linux/mac都有GPU版本的whl. 此问题详细谈论可以参考:&lt;a href="https://github.com/samjabrahams/tensorflow-on-raspberry-pi/issues/15"&gt;Question on GPU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使树莓派超频可以加快运算速度&lt;/li&gt;
&lt;li&gt;把tensorflow部署到小车控制器坐在的电脑上（本地电脑），实际计算在本地进行（这样可以把tensorflow用到任何client里，不过需要联网运行）&lt;/li&gt;
&lt;li&gt;把tensorflow部署到云上，提供网络服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一个优化是，缩小图片尺寸，可以使用ImageMagick提供的convert指令：&lt;code&gt;convert -resize 100x100 test.png dest.jpg&lt;/code&gt;。 如此一来就把图片转化为小尺寸（100x100），能有效提高运算速度&lt;/p&gt;
&lt;h1&gt;todo&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;中文语音输出&lt;ul&gt;
&lt;li&gt;蓝牙音箱&lt;/li&gt;
&lt;li&gt;英-&amp;gt;中翻译&lt;/li&gt;
&lt;li&gt;语音输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加载到汽车模型上&lt;ul&gt;
&lt;li&gt;L298N驱动板&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE"&gt;维基百科 树莓派&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.oreilly.com/learning/how-to-build-a-robot-that-sees-with-100-and-tensorflow"&gt;How to build a robot that “sees” with $100 and TensorFlow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/pi_examples"&gt;pi_examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate><guid>tag:,2016-10-23:raspberrypi-tensowflow-robot.html</guid><category>tools</category></item><item><title>用树莓派给家用电器加上智能（红外篇）</title><link>/raspberrypi-lirc.html</link><description>&lt;h1&gt;ideas&lt;/h1&gt;
&lt;p&gt;许多家电是红外控制的，与外界的交互通过一个红外遥控器,我们能否通过编程使其变成智能家居呢，好比我们想做这样一件事：&lt;code&gt;夏天傍晚下班前，检查室内温度，如果室温高于30摄氏度，则打开空调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要做到上边这件事，我们未必需要购买最新的带app控制的智能空调，利用旧式空调也可以。空调由红外遥控器控制，如果我们能控制红外的收发,模拟发射这些控制信号，我们就可以hack这些旧家电，使其可编程，变成&lt;code&gt;智能家电&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;目标&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;红外线控制&lt;/li&gt;
&lt;li&gt;微信控制&lt;/li&gt;
&lt;li&gt;自然语言控制（chatbot）&lt;/li&gt;
&lt;li&gt;blockly编程控制&lt;/li&gt;
&lt;li&gt;与其他传感器组合（温湿度）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;硬件环境&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;树莓派(我的当前环境是树莓派3,其他版本也可以)&lt;/li&gt;
&lt;li&gt;红外接收器/红外发射器（我用的是这款&lt;a href="http://ukonline2000.com/?p=296"&gt;红外线扩展板&lt;/a&gt;,能同时支持红外收发）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a href="https://zh.wikipedia.org/zh-hans/LIRC"&gt;LIRC&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;LIRC是我们需要的软件.&lt;/p&gt;
&lt;p&gt;LIRC 是 Linux Infrared remote control的缩写，是linux系统下开源的软件包。从名字中可知，这个软件让你的Linux系统能够控制红外线信号。&lt;/p&gt;
&lt;p&gt;LIRC有个具有图形用户界面的前端，叫做KDELirc&lt;/p&gt;
&lt;p&gt;在使用LIRC之前建议了解一下&lt;a href="http://www.cnblogs.com/yulongchen/archive/2013/04/12/3017409.html"&gt;红外协议&lt;/a&gt;，这样有助于你理解交互过程和debug&lt;/p&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;sudo apt-get install lirc&lt;/p&gt;
&lt;h3&gt;配置&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#sudo vim /boot/config.txt #在文件结尾添加
dtoverlay=lirc-rpi
gpio_in_pin=18
gpio_out_pin=17

#sudo vim /etc/lirc/hardware.conf  #编辑LRIC的配置文件
LIRCD_ARGS=&amp;quot;--uinput --listen&amp;quot;
DRIVER=&amp;quot;default&amp;quot;
DEVICE=&amp;quot;/dev/lirc0&amp;quot;
MODULES=&amp;quot;lirc_rpi&amp;quot;

# 重启生效
sudo /etc/init.d/lirc restart

# irrecord --list-namespace
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;录制电风扇&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 开始录制
irrecord -d /dev/lirc0 ~/lircd.conf #按照提示操作即可,录制完后会让你输入按键名

sudo cp ~/lircd.conf /etc/lirc/lircd.conf

#查看录制好可以使用的按键名
irsend LIST /home/pi/lircd.conf &amp;quot;&amp;quot;
irsend SEND_ONCE /home/pi/lircd.conf KEY_POWER
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;录制空调红外&lt;/h3&gt;
&lt;p&gt;空调遥控器这种带逻辑控制的比较麻烦.每次发射的都是含有温度、模式、制冷制热等一连串的指令，按照之前irrecord指令生成conf文件，行不通&lt;/p&gt;
&lt;p&gt;只能使用raw的原始码，记录也是通过mode2 命令实现&lt;/p&gt;
&lt;p&gt;先制作模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo /etc/init.d/lirc restart
irrecord  -f -d /dev/lirc0 ~/lircd.conf #制作模板
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;得到&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;begin remote

  name  /home/pi/lircd.conf
  flags RAW_CODES
  eps            30
  aeps          100

  gap          19886

      begin raw_codes

          name KEY_OPEN
               90     102     331

      end raw_codes

end remote
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来开始录制&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mode2  -d /dev/lirc0 &amp;gt; /tmp/temp.code  &lt;span class="c1"&gt;# space 10969878 &lt;/span&gt;
cat /tmp/temp.code &lt;span class="p"&gt;|&lt;/span&gt; sed -n &lt;span class="s1"&gt;&amp;#39;2,$p&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -o  -E &lt;span class="s2"&gt;&amp;quot;[0-9]+&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; xargs &lt;span class="nb"&gt;echo&lt;/span&gt;  &lt;span class="c1"&gt;# 移除第一行,之后把所有数字取出&lt;/span&gt;
&lt;span class="c1"&gt;# 把上述指令写入 ~/lircd.conf 的 KEY_OPEN里&lt;/span&gt;
&lt;span class="c1"&gt;# 值得注意的是 ~/lircd.conf文件里的空格十分重要&lt;/span&gt;

sudo cp ~/lircd.conf /etc/lirc/lircd.conf
sudo /etc/init.d/lirc restart
&lt;span class="c1"&gt;# irsend LIST /home/pi/lircd.conf &amp;quot;&amp;quot; #列出指令&lt;/span&gt;
irsend SEND_ONCE /home/pi/lircd.conf KEY_OPEN
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是我最后的~/lircd.conf内容:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;begin remote

  name  /home/pi/lircd.conf
  flags RAW_CODES
  eps            30
  aeps          100

  gap          19886

      begin raw_codes

          name KEY_CLOSE
               9075 4411 731 453 751 1580 730 476 729 477 731 1576 729 478 729 1579 729 460 747 477 729 477 729 476 730 1578 729 477 730 476 731 477 733 472 730 476 731 475 730 477 728 480 728 477 729 1578 731 477 727 477 731 475 730 478 728 477 730 476 730 1578 754 430 753 1577 735 471 730 477 752 1553 756 453 753 19884 756 1551 758 451 754 450 756 451 756 451 754 449 756 451 757 429 777 449 758 449 758 449 756 451 755 450 756 1550 757 428 779 451 755 451 755 450 757 450 755 450 757 428 779 449 757 448 760 447 758 449 757 449 756 451 756 450 756 449 756 1551 757 1550 757 451 756
          name KEY_OPEN
               9112 4390 724 459 747 1584 725 459 746 1582 727 1582 726 481 724 1583 726 482 729 478 745 459 726 481 745 1564 724 480 725 481 746 459 725 488 741 438 770 457 748 457 749 459 747 459 748 1559 748 436 773 455 750 457 748 459 748 457 750 458 747 1559 749 459 746 1558 750 457 749 458 748 1558 751 455 749 19889 748 1559 750 457 748 458 749 458 750 457 747 458 748 458 749 435 771 458 749 457 748 459 745 461 745 460 747 1561 726 481 729 455 769 458 725 482 725 481 724 483 724 481 726 482 745 460 725 482 725 482 722 482 726 482 725 481 724 480 724 1583 725 1582 727 1583 726


      end raw_codes

end remote
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我把开关机命名为KEY_OPEN/KEY_CLOSE(可以完全自定义)&lt;/p&gt;
&lt;p&gt;之后开关机的指令分别为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#开机
irsend SEND_ONCE /home/pi/lircd.conf KEY_OPEN
#关机
irsend SEND_ONCE /home/pi/lircd.conf KEY_CLOSE
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;测试有效！搞定&lt;/p&gt;
&lt;p&gt;之后结合温度传感器或者微信之类的其他功能模块就可以完成丰富的智能控制了&lt;/p&gt;
&lt;h1&gt;坑&lt;/h1&gt;
&lt;p&gt;配置文件中，KEY的名字有限制，BLOCKLY_KEY会报错 KEY_BLOCKLY就行&lt;/p&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/LIRC"&gt;LIRC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mageelen.blog.163.com/blog/static/1769430102014382346166/"&gt;使用树莓派遥控空调&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/yulongchen/archive/2013/04/12/3017409.html"&gt;红外协议之NEC协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://linux.cn/article-3782-1.html"&gt;使用树莓派红外控制空调和风扇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ukonline2000.com/?p=296"&gt;发布树莓派专用红外线扩展板&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate><guid>tag:,2016-10-17:raspberrypi-lirc.html</guid><category>tools</category></item><item><title>树莓派折腾笔记之系统安装与配置</title><link>/raspberrypi-install-and-config.html</link><description>&lt;p&gt;最近我的树莓派被用于作原型机了&lt;/p&gt;
&lt;p&gt;只好重新用新的板子重新配置&lt;/p&gt;
&lt;h1&gt;下载系统镜像&lt;/h1&gt;
&lt;p&gt;镜像&lt;a href="https://www.raspberrypi.org/downloads/"&gt;下载地址&lt;/a&gt;,这里有许多可选镜像,我用的是&lt;a href="https://www.raspberrypi.org/downloads/raspbian/"&gt;raspbian&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我之前是在windows下用win32diskimager往sd卡里刷系统的&lt;/p&gt;
&lt;p&gt;这次准备用dd(方便批量操作)，在mac下.参考这篇文章：&lt;a href="https://github.com/ccforward/cc/issues/25"&gt;Mac下给SD卡安装树莓派Raspbian系统&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;安装系统&lt;/h1&gt;
&lt;p&gt;这里我们讨论两种情况，新买的sd卡和已经安装过系统的sd卡（重刷）&lt;/p&gt;
&lt;h3&gt;新的sd卡&lt;/h3&gt;
&lt;p&gt;一般新买的卡都已经格式化好了，这是最简单的情况,  按照&lt;a href="https://github.com/ccforward/cc/issues/25"&gt;Mac下给SD卡安装树莓派Raspbian系统&lt;/a&gt;的做法就行,微软下快速格式化可能会有问题(没有做分区)&lt;/p&gt;
&lt;p&gt;这里复述一下核心内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;df &lt;span class="c1"&gt;# 查看当前已经挂载的卷&lt;/span&gt;
&lt;span class="c1"&gt;# 假设设备文件为：/dev/disk1s1 ,（ 通过查看设备名判断）&lt;/span&gt;
diskutil unmount /dev/disk1s1 &lt;span class="c1"&gt;#卸载&lt;/span&gt;
diskutil list &lt;span class="c1"&gt;# 确认设备  (通过存储大小)&lt;/span&gt;
&lt;span class="c1"&gt;# 安装系统&lt;/span&gt;
dd &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;4m &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;pi.img &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/rdisk1 &lt;span class="c1"&gt;#我的速度大概是17m/s&lt;/span&gt;
diskutil unmountDisk /dev/disk1  &lt;span class="c1"&gt;#卸载设备&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;至此，系统就刷好了&lt;/p&gt;
&lt;h3&gt;重刷装有系统的sd卡&lt;/h3&gt;
&lt;p&gt;如果是重刷装有系统的sd卡,我们需要先把SD卡还原成初始状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载&lt;a href="http://www.alexpage.de/download/usbit/bootsector.img"&gt;bootsector.img&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;dd bs=4m if=./bootsector.img of=/dev/rdisk1 # 假设设备为disk1 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后格式化sd卡(我把它格式化为MS-DOS(FAT))，至此你就可以把它当做新卡，用处理新卡的方式安装系统了&lt;/p&gt;
&lt;h1&gt;登录系统&lt;/h1&gt;
&lt;p&gt;我只买了树莓派，没有买高清转接头之类的东西，没打算把树莓派连到屏幕。那么我们如何登录系统，进行操作呢&lt;/p&gt;
&lt;p&gt;首先使用网络连接树莓派网口，然后找个扫描ip的软件,我用的是fing（mac和iphone都有），手机/电脑只要和树莓派在同个网络里，就可以找到它（通过设备名） （ps: brew cask install fing）&lt;/p&gt;
&lt;p&gt;然后ssh登录即可，用户名和密码分别是：pi/raspberry （11-25版本可能需要先进用屏幕登录在raspi-config里开启ssh:&lt;a href="https://www.raspberrypi.org/blog/a-security-update-for-raspbian-pixel/"&gt;A SECURITY UPDATE FOR RASPBIAN PIXEL&lt;/a&gt;) 文章提到如果你想默认默认ssh只需要在sd卡/boot/里加上&lt;code&gt;ssh&lt;/code&gt;文件就行，内容无所谓，可以为空&lt;/p&gt;
&lt;p&gt;树莓派3代自带无线网卡，我们把无线网卡连上wifi，之后就不需要，细节下文再说&lt;/p&gt;
&lt;h1&gt;配置&lt;/h1&gt;
&lt;p&gt;输入&lt;code&gt;sudo raspi-config&lt;/code&gt;开始设置，相关设置可以看说明&lt;/p&gt;
&lt;h2&gt;#Expand Filesystem&lt;/h2&gt;
&lt;p&gt;扩展 SD 卡上可用的空间, 否则你会觉得怎么可用空间这么小&lt;/p&gt;
&lt;h3&gt;配置&lt;a href="https://zh.wikipedia.org/zh/VNC"&gt;VNC&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;VNC借由网络，可发送键盘与鼠标的动作及即时的屏幕画面&lt;/p&gt;
&lt;p&gt;VNC与操作系统无关，因此可跨平台使用&lt;/p&gt;
&lt;p&gt;我在mac下使用RealVNC&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install tightvncserver &lt;span class="c1"&gt;# 安装&lt;/span&gt;
vncserver :1 &lt;span class="c1"&gt;# 启用 ，之后在 vnc client里输入 ip:1即可进入图形界面&lt;/span&gt;
&lt;span class="c1"&gt;# vncpasswd # 修改密码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;换国内源&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;#sudo vi /etc/apt/sources.list ,使内容变为&lt;/span&gt;
&lt;span class="k"&gt;deb&lt;/span&gt; &lt;span class="s"&gt;http://mirrors.aliyun.com/raspbian/raspbian/&lt;/span&gt; &lt;span class="kp"&gt;jessie&lt;/span&gt; &lt;span class="kp"&gt;main&lt;/span&gt; &lt;span class="kp"&gt;non-free&lt;/span&gt; &lt;span class="kp"&gt;contrib&lt;/span&gt;
&lt;span class="k"&gt;deb-src&lt;/span&gt; &lt;span class="s"&gt;http://mirrors.aliyun.com/raspbian/raspbian/&lt;/span&gt; &lt;span class="kp"&gt;jessie&lt;/span&gt; &lt;span class="kp"&gt;main&lt;/span&gt; &lt;span class="kp"&gt;non-free&lt;/span&gt; &lt;span class="kp"&gt;contrib&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;修改hostname&lt;/h3&gt;
&lt;p&gt;sudo vim /etc/hostname&lt;/p&gt;
&lt;h3&gt;无线网络&lt;/h3&gt;
&lt;p&gt;如果你直接在命令行里配置可以参考:&lt;a href="http://www.jianshu.com/p/b42e8d3df449"&gt;树莓派 Raspberry Pi 设置无线上网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改配置文件:&lt;code&gt;/etc/network/interfaces&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto wlan0
iface wlan0 inet dhcp
wpa-conf /etc/wpa.conf
iface default inet dhcp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之后在&lt;code&gt;/etc/wpa.conf&lt;/code&gt;里加上你的无线热点(可以添加多个)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;network={
        ssid=&amp;quot;xxx&amp;quot;
        key_mgmt=WPA-PSK
        psk=&amp;quot;xxx&amp;quot;
        id_str=&amp;quot;myiphone&amp;quot;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;无线网卡的控制命令为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo ifup wlan0 &lt;span class="c1"&gt;#启用&lt;/span&gt;
sudo ifdown wlan0 &lt;span class="c1"&gt;#关闭&lt;/span&gt;
sudo service network-manager restart &lt;span class="c1"&gt;#重启&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更直观的配置方式可以使用VNC client进入图形环境里&lt;/p&gt;
&lt;p&gt;如果你外接了usb网卡,记得加驱动,诸如(&lt;code&gt;sudo apt-get install firmware-realtek&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;如果有错，查看日志:&lt;code&gt;/var/log/syslog&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;树莓派作为无线AP&lt;/h3&gt;
&lt;p&gt;使用&lt;a href="https://github.com/oblique/create_ap"&gt;create_ap&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/oblique/create_ap
cd create_ap
sudo make install
#安装依赖
sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq  #dnsmasq 是dns服务器

sudo create_ap wlan0 eth0 wwjpi3 wwjpipass --no-virt # https://github.com/oblique/create_ap/issues/185
# 加到supervisor里 #/usr/bin/create_ap  wlan0 eth0 wwjpi3 wwjpipass --no-virt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输煤派的地址为：&lt;code&gt;192.168.12.1&lt;/code&gt; , 路由器的地址为 &lt;code&gt;192.168.0.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进一步的发挥空间，我们可以把它当做一个钓鱼热点(已经运行了53端口DNS服务器)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果同时使用无线ap和普通wifi网卡，建议开机后再加入wifi网卡，然后ifup启用，否则可能导致热点无法开机启动&lt;/p&gt;
&lt;h4&gt;DHCP服务&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install dnsmasq
# vim /etc/dnsmasq.conf
interface=wlan0  #可能会影响wifi_ap
bind-interfaces
address=/#/192.168.12.1  #将对所有网站的访问重定向到本机

sudo service dnsmasq restart
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;连接VPN&lt;/h3&gt;
&lt;p&gt;安装客户端: &lt;code&gt;sudo apt-get install pptp-linux&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用root用户创建/etc/ppp/peers/vpn&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pty &amp;quot;pptp XXX.XXX.XXX.XXX --nolaunchpppd&amp;quot;
name 用户名
password 密码
remotename PPTP
require-mppe-128
require-mschap-v2
refuse-eap
refuse-pap
refuse-chap
refuse-mschap
noauth
persist
maxfail 0
defaultroute
replacedefaultroute
usepeerdns
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;启动/断开vpn:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pon vpn
poff vpn
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;蓝牙&lt;/h3&gt;
&lt;p&gt;树莓派3自带蓝牙&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/etc/init.d/bluetooth status &lt;span class="c1"&gt;# 查看蓝牙状态&lt;/span&gt;
sudo bluetoothctl &lt;span class="c1"&gt;#进入蓝牙程序,替代了原来的bluez-simple-agent&lt;/span&gt;
&lt;span class="c1"&gt;# 之后按照步骤连接 &lt;/span&gt;
&lt;span class="c1"&gt;# 试一首歌&lt;/span&gt;
apt-get install mpg123
mpg123 mp3_uri
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;蓝牙图形界不稳定，命令行的操作为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bluetoothctl
power on
scan on
agent on
pair #DD:8E:F1:CA:B8:9F #my bb8
trust DD:8E:F1:CA:B8:9F
connect DD:8E:F1:CA:B8:9F
quit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/20713396"&gt;树莓派3 model:B 连接蓝牙设备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.embbnux.com/2016/04/10/raspberry_pi_3_wifi_and_bluetooth_setting_on_console/"&gt;树莓派3命令行配置wifi无线连接和蓝牙连接&lt;/a&gt;：rpi3蓝牙连音箱比较麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果蓝牙连接好 却无法播放声音，可能是默认的声音输出是系统声卡，设置&lt;code&gt;PulseAudio Volume Control&lt;/code&gt;，在设置里把bcm2835设置为off&lt;/p&gt;
&lt;h3&gt;音频相关&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;play&lt;/li&gt;
&lt;li&gt;mplayer/mpg123&lt;/li&gt;
&lt;li&gt;sox 录音&lt;/li&gt;
&lt;li&gt;alsamixer 调节音量&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sox -d /tmp/recording.wav
play /tmp/recording.wav
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;坑&lt;/h3&gt;
&lt;p&gt;使用蓝牙音箱时，尽量不要同时将树莓派作为作为热点，否则可能导致声音卡顿&lt;/p&gt;
&lt;h4&gt;PyAudio&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install libportaudio0 libportaudio2 libportaudiocpp0 portaudio19-dev 
sudo pip install PyAudio
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;其它&lt;/h3&gt;
&lt;h4&gt;我的编程环境&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install vim git tmux ack-grep lynx

&lt;span class="c1"&gt;# 我的vim配置文件 &lt;/span&gt;
wget https://raw.githubusercontent.com/wwj718/wwj718-vim/master/wwj718_vim_vimrc -O ~/.vimrc
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;jupyter lab （开发环境）&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo pip install pip --upgrade -i http://pypi.douban.com/simple
sudo apt-get install python-dev

&lt;span class="c1"&gt;# jupyter&lt;/span&gt;
sudo pip install jupyter  -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
sudo pip install jupyterlab  -i http://pypi.douban.com/simple --trusted-host pypi.douban.com

sudo jupyter serverextension &lt;span class="nb"&gt;enable&lt;/span&gt; --py jupyterlab --sys-prefix
&lt;span class="c1"&gt;# jupyter lab --notebook-dir=&amp;quot;.&amp;quot; --no-browser --port 5000 --ip=0.0.0.0 &lt;/span&gt;
&lt;span class="c1"&gt;# vim ~/.bashrc&lt;/span&gt;
&lt;span class="c1"&gt;# alias jupyterlab=&amp;quot;jupyter lab --notebook-dir=&amp;quot;.&amp;quot; --no-browser --port 8888 --ip=0.0.0.0&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# jupyter notebook --no-browser --port 5000 --ip=0.0.0.0 &lt;/span&gt;
&lt;span class="c1"&gt;# 属于jupyter作为开发环境&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;&lt;a href="https://github.com/rupa/z"&gt;z&lt;/a&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget https://raw.githubusercontent.com/rupa/z/master/z.sh -O ~/z.sh
&lt;span class="c1"&gt;# 在.bashrc添加 ~/.bashrc&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; . ~/z.sh &amp;gt; ~/.bashrc
&lt;span class="c1"&gt;# souce ~/.bashrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;GPIO相关&lt;/h1&gt;
&lt;h3&gt;I2C&lt;/h3&gt;
&lt;p&gt;如果要用Adafruit_LED_Backpack,需要开启I2C&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install python-smbus
sudo apt-get install i2c-tools
sudo raspi-config &lt;span class="c1"&gt;#advanced options&lt;/span&gt;
sudo vim  /etc/modules &lt;span class="c1"&gt;# add i2c-bcm2708 and i2c-dev &lt;/span&gt;
&lt;span class="c1"&gt;# reboot&lt;/span&gt;
&lt;span class="c1"&gt;# test&lt;/span&gt;
sudo i2cdetect -y 1
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;系统管理与监控&lt;/h1&gt;
&lt;h3&gt;Linux Dash&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A beautiful web dashboard for Linux&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/afaqurk/linux-dash
&lt;span class="nb"&gt;cd&lt;/span&gt; linux-dash
sudo python https://github.com/afaqurk/linux-dash
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认80端口&lt;/p&gt;
&lt;h1&gt;摄像头&lt;/h1&gt;
&lt;p&gt;我使用的是官方摄像头，连上后&lt;/p&gt;
&lt;p&gt;sudo raspi-config #Enable Camera&lt;/p&gt;
&lt;p&gt;查看是否正常:&lt;code&gt;ls /dev/video*&lt;/code&gt;,如果有video0就正常,如果没有，则 &lt;code&gt;sudo modprobe bcm2835-v4l2&lt;/code&gt; ,写入/etc/rc.local以保证开机运行&lt;/p&gt;
&lt;h3&gt;截个图&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install fswebcam
fswebcam -r 1280x720 /tmp/image1.jpg
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;motion&lt;/h3&gt;
&lt;p&gt;监控与动作捕捉（像素变化）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install motion&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置:`sudo vim /etc/motion/motion.conf&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;daemon off #on则后台运行
stream_localhost off #可以局域网内访问，否则只能localhost访问
webcontrol_localhost off
quiet on
videodevice /dev/video0
framerate 2 #30 很流畅 但是时间快
stream_maxrate 1 #30 
auto_brightness off
#target_dir /home/pi/camera_data
ffmpeg_output_movies on #输出视频（变化）
output_pictures off #输出图片
width 640
height 480
threshold 500 #灵敏度,变化的像素，决定是否捕捉
max_movie_time 5  #拍摄时间
logfile /tmp/motion.log
#noise_level 60
# event
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行 ：&lt;code&gt;sudo motion&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;访问：&lt;code&gt;ip:8081&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认存储在/var/lib/motion&lt;/p&gt;
&lt;h3&gt;在python中调用&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pygame&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pygame.camera&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pygame.locals&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="c1"&gt;# initialize&lt;/span&gt;
&lt;span class="n"&gt;pygame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;pygame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;camera&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# capture a image&lt;/span&gt;
&lt;span class="n"&gt;camera&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pygame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;camera&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Camera&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/dev/video0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;640&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;480&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;camera&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;camera&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_image&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;pygame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;image.jpg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;camera&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;机器视觉&lt;/h3&gt;
&lt;h3&gt;netdata&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Get control of your servers. Simple. Effective. Awesome&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install zlib1g-dev uuid-dev libmnl-dev gcc make git autoconf autoconf-archive autogen automake pkg-config curl
git clone https://github.com/firehol/netdata.git --depth&lt;span class="o"&gt;=&lt;/span&gt;1
&lt;span class="nb"&gt;cd&lt;/span&gt; netdata

&lt;span class="c1"&gt;# build it, install it, start it&lt;/span&gt;
sudo ./netdata-installer.sh
&lt;span class="c1"&gt;# 访问ip:19999&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;相关数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   - the daemon     at /usr/sbin/netdata
   - config files   in /etc/netdata
   - web files      in /usr/share/netdata
   - plugins        in /usr/libexec/netdata
   - cache files    in /var/cache/netdata
   - db files       in /var/lib/netdata
   - log files      in /var/log/netdata
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;卸载:&lt;code&gt;sudo  ./netdata-uninstaller.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要监控nginx，需要做些配置：&lt;a href="https://github.com/firehol/netdata/tree/master/python.d#nginx"&gt;netdata nginx&lt;/a&gt;，&lt;a href="https://github.com/firehol/netdata/wiki/The-spectacles-of-a-web-server-log-file"&gt;The spectacles of a web server log file&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;编译nginx

--with-http_stub_status_module
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;supervisor&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Supervisor process control system for UNIX&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#切换到sudo用户&lt;/span&gt;
pip install supervisor
&lt;span class="c1"&gt;#echo_supervisord_conf &amp;gt; /etc/supervisord.conf&lt;/span&gt;
mkdir  /etc/supervisor
echo_supervisord_conf &amp;gt; /etc/supervisor/supervisord.conf &lt;span class="c1"&gt;#这个配置Ajenti才能管理&lt;/span&gt;
mkdir /etc/supervisord.conf.d
&lt;span class="c1"&gt;# 修改配置文件,include区段修改为 files = /etc/supervisord.conf.d/*.conf&lt;/span&gt;
&lt;span class="c1"&gt;# 开机自启 . 往/etc/rc.local加入/usr/local/bin/supervisord&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;supervisor的web管理端口为9001，需要开启&lt;/p&gt;
&lt;p&gt;添加新的进程配置，可以使用下边介绍的Ajenti来做, 配置信息会被直接写入：/etc/supervisor/supervisord.conf&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://github.com/yudai/gotty"&gt;gotty&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;gotty可以把terminal分享到web,默认端口是8080&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 下载https://github.com/yudai/gotty/releases ，我下的是gotty_linux_arm.tar.gz&lt;/span&gt;
gotty -w vim &lt;span class="c1"&gt;#把vim已编辑方式分享出来,分享vim就够了，vim可以切换到bash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们把8080端口用ngrok分享出来（ngrok用supervisor管理），实际就是一个后门，用作开发调试十分方便&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://github.com/ajenti/ajenti"&gt;Ajenti&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Ajenti可以让你很简单地配置不同的常规服务程序，如Apache/nginx、Samba、BIND、Squid、MySQL、cron、防火墙等等&lt;/p&gt;
&lt;p&gt;十分适合非技术用户配置系统应用，可以看做服务器管理面板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget http://repo.ajenti.org/debian/key -O- &lt;span class="p"&gt;|&lt;/span&gt; apt-key add -
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;deb http://repo.ajenti.org/debian main main debian&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/apt/sources.list
sudo apt-get install ajenti
sudo apt-get install build-essential python-pip python-dev python-lxml libffi-dev libssl-dev libjpeg-dev libpng-dev uuid-dev python-dbus
&lt;span class="c1"&gt;# sudo easy_install -U pip #先升级,16.5.27的版本原始pip可能报错&lt;/span&gt;
sudo pip install ajenti-panel ajenti.plugin.dashboard ajenti.plugin.settings ajenti.plugin.plugins
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认端口8000，默认登录信息为：&lt;code&gt;root:admin&lt;/code&gt;，之后修改密码之类的都在控制面板里边做&lt;/p&gt;
&lt;p&gt;配置文件为:&lt;code&gt;/etc/ajenti/config.json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认开机自启&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/ajenti69406213.png" /&gt;&lt;/p&gt;
&lt;h1&gt;国内源安装nodejs&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#注意编译非常慢
wget https://npm.taobao.org/mirrors/node/v6.9.1/node-v6.9.1.tar.gz
tar zxvf node-v6.9.1.tar.gz 
cd node-v6.9.1.tar.gz/ 
./configure 
sudo make install 
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;坑&lt;/h1&gt;
&lt;p&gt;09-23的版本坑多&lt;/p&gt;
&lt;h3&gt;zip包mac下无法解压&lt;/h3&gt;
&lt;p&gt;在linux和window下都行&lt;/p&gt;
&lt;h3&gt;ssh端口拒绝&lt;/h3&gt;
&lt;p&gt;ip能ping通，ssh端口关闭，怀疑是ssh server没有开启&lt;/p&gt;
&lt;p&gt;nmap -p 22 xxx 测试关闭，fuck&lt;/p&gt;
&lt;p&gt;建议下载&lt;a href="https://downloads.raspberrypi.org/raspbian/images/raspbian-2016-05-31/2016-05-27-raspbian-jessie.zip"&gt;5-27版本&lt;/a&gt;,所有版本在这里：&lt;a href="https://downloads.raspberrypi.org/"&gt;downloads.raspberrypi.org&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.shumeipai.net/thread-1263-1-1.html?_dsign=55be35fa"&gt;用镜像写入工具将安装过树莓派系统的SD卡还原卡&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Tue, 11 Oct 2016 00:00:00 +0000</pubDate><guid>tag:,2016-10-11:raspberrypi-install-and-config.html</guid><category>tools</category></item><item><title>树莓派守护者!</title><link>/pi-guardian.html</link><description>&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pi_swzbe54be0b.png" /&gt;&lt;/p&gt;
&lt;h1&gt;老虎机与行窃少年&lt;/h1&gt;
&lt;p&gt;那年我大概十岁。&lt;/p&gt;
&lt;p&gt;家门口小店入驻了一台老虎机,每天放学回家路过小店，机器周围，围观者众。&lt;/p&gt;
&lt;p&gt;晚饭后喜欢跑到小店，看人们下注、击键、大笑、咒骂、跺脚，我喜欢老虎机侧边的位置，从这里透过机器的缝隙，看得到里边的电路板，上边数字闪烁，毫无规律&lt;/p&gt;
&lt;p&gt;此后许久，我对老虎机的兴趣一直很浓厚，多年之后，在大学图书馆的一角，饶有兴致地读到老虎机算法作者的书籍，他谈到你不可能赢过机器，唯一的获胜机会就是赢取你的同伴：你将机器视为中介，根据前边参与者的胜负，决定你的策略，这是你唯一获胜的可能&lt;/p&gt;
&lt;p&gt;某天一早，小店门口停着警车，热闹非凡，凑热闹这种事十岁小孩再感兴趣不过了。挤入小店，看到4个少年垂首丧气，双手被扣,十五六岁年纪. 是店里老虎机坐上常客。&lt;/p&gt;
&lt;p&gt;好事者纷纷问缘由，老板春风满面, 说起这群少年，如何三番五次，入室盗窃，手法精巧，行事谨慎. &lt;/p&gt;
&lt;p&gt;人们又问，你既说他们机智，你又如何逮到他们。&lt;/p&gt;
&lt;p&gt;老板等的便是这句，登时状如登上领奖台做获奖感言. 老板说自己早便发现他们入室盗窃，为了证据确凿，设计了一套精巧的陷阱：在柜台入口，近地面处系一根绳子，绳子一直连到老板睡觉的卧室，在卧室里系上易拉罐。少年们再次登门，触发开关，弄倒老板卧室的易拉罐，老板醒后，有备而来，少年们毫无知觉，来个瓮中捉鳖&lt;/p&gt;
&lt;p&gt;末了老板感叹一句这等聪明，用到学习上得多出色&lt;/p&gt;
&lt;p&gt;人们纷纷赞叹&lt;/p&gt;
&lt;h1&gt;基于树莓派的报警器&lt;/h1&gt;
&lt;p&gt;故事里，有一处不够优美:报警器竟是绳子做的！如果少年们更警觉些，看到绳子，或是踩到之后便逃离，老板恐怕要竹篮打水一场空。&lt;/p&gt;
&lt;p&gt;我们可以基于树莓派来重构报警器&lt;/p&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;将超声波传感器（或者红外线）放在柜台下边，当有人路过时，树莓派给老板手机发送一条短信（或邮件），这个隐形的卫士几乎没有破绽&lt;/p&gt;
&lt;h3&gt;实现（硬件）&lt;/h3&gt;
&lt;p&gt;硬件部分，我们使用移动电源为树莓派供电，便于藏匿（移动电源可用大约一周）&lt;/p&gt;
&lt;p&gt;接线图如下(只需要关注超声波传感器)：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/wwj718/gif_bed/master/pi_fritzing.png" /&gt;&lt;/p&gt;
&lt;h3&gt;实现（软件）&lt;/h3&gt;
&lt;p&gt;软件部分，我已经把源码放到这里了：&lt;a href="https://github.com/wwj718/raspberrypi_lab"&gt;raspberrypi_lab&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个项目的核心是，利用超声波传感器测距，当传感器前边有物体时，距离将发生变化，于是触发其他函数（发邮件）即可,核心源码为:&lt;a href="https://github.com/wwj718/raspberrypi_lab/blob/master/echo_main.py"&gt;echo_main&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你想发送邮件，使用python的smtp库即可，如果你想发送短信，可以使用Twilio的api:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;twilio.rest&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;TwilioRestClient&lt;/span&gt;
&lt;span class="n"&gt;account&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;xxx&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;xxx&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TwilioRestClient&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;account&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;messages&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+86137xxx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;from_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+166xxx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Wake up!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码跑起来后，把它放柜台下，有人路过时，即可悄无声息地发送短信报警!&lt;/p&gt;
&lt;h1&gt;守护你的私密空间&lt;/h1&gt;
&lt;p&gt;我们来继续发挥&lt;code&gt;守护者&lt;/code&gt;这个概念，这次的目的是为了保护在房间里不好好学习，爱瞎折腾的你&lt;/p&gt;
&lt;p&gt;想想你在自己房间里看哆啦A梦(当然你也可以看些别的(羞射脸))&lt;/p&gt;
&lt;p&gt;班主任正在你家客厅家访。搞得你看动画片都不踏实,深怕有人破门而入&lt;/p&gt;
&lt;p&gt;让我们发挥geek精神，把树莓派打造为私密空间守护者。这个守护者的职责是：当有人进入房间时，在led矩阵上亮起笑脸以示欢迎，同时用蜂鸣器演奏一首歌吸引注意(我用了葫芦娃，你可以用老师窗前之类的 ^_^)&lt;/p&gt;
&lt;p&gt;led矩阵的源码如下：&lt;a href="https://github.com/wwj718/raspberrypi_lab/blob/master/smile.py"&gt;smile.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;蜂鸣器部分的源码为:&lt;a href="https://github.com/wwj718/raspberrypi_lab/blob/master/beep.py"&gt;beep.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当门被打开时，超声波传感器将感觉到障碍物的出现，这是触发笑脸和音乐，最有意思的是下一步&lt;/p&gt;
&lt;h3&gt;切换电脑屏幕&lt;/h3&gt;
&lt;p&gt;你要知道你这个时候正看哆啦A梦看得兴起,你可能沉迷其中，听到音乐也来不及切换电脑屏幕，上班这段动作是典型的&lt;code&gt;触发&lt;/code&gt;模式，适合让机器来做，把它自动化！&lt;/p&gt;
&lt;p&gt;我们在电脑上跑起来一个进程，这个进程是个web服务，可以被调用，当被调用时（来自树莓派的http请求），我们的电脑屏幕将自动切换到iBook阅读界面，切换速度在毫秒级别，老师/家长一进门，便看到你在津津有味地看书，因为你还没从动画片里缓过神，肯定盯住屏幕的书。老师欣然离去&lt;/p&gt;
&lt;p&gt;这是打开之前你的屏幕：
&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pi_guardian083cd92b.png" /&gt;&lt;/p&gt;
&lt;p&gt;哦不对，拿错图片了：
&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pi_guardiancea87d3d.png" /&gt;&lt;/p&gt;
&lt;p&gt;这是房门打开之后你的屏幕：
&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pi_guardian3aae2aad.png" /&gt;&lt;/p&gt;
&lt;p&gt;这个web服务的源码在这里：&lt;a href="https://github.com/wwj718/raspberrypi_lab/blob/master/pc_server.py"&gt;pc_server&lt;/a&gt;, 这个功能涉及代码很短，只有几行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/study&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;study&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;to study&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;open&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/Applications/iBooks.app&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; 
    &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;study&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有了树莓派守护者，你就可以不必反锁房门，在你的电脑上做任何事儿, 不用担心被察觉啦&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Fri, 07 Oct 2016 00:00:00 +0000</pubDate><guid>tag:,2016-10-07:pi-guardian.html</guid><category>技术</category></item><item><title>在树莓派上搭建代码托管服务器</title><link>/pi-gogs-install.html</link><description>&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pi3e0c84b0.png" /&gt;&lt;/p&gt;
&lt;p&gt;最近公司有个好玩的项目，准备采用树莓派/arduino作为原型机，恰好我的玩具箱里两者都有&lt;/p&gt;
&lt;p&gt;擦擦尘土，把树莓派带到公司&lt;/p&gt;
&lt;p&gt;上周把arduino借给老板了，各种传感器也在其中，他出差没回，我的树莓派没有传感器可用，只要先折腾些软件应用&lt;/p&gt;
&lt;p&gt;公司的代码托管服务器是我之前搭建的（用了&lt;a href="https://github.com/gogits/gogs"&gt;gogs&lt;/a&gt;），我们部门搬到楼下，连接代码托管服务器需要vpn（网络的坑），速度不快，索性决定，在下边也搭建一个代码托管服务器。&lt;/p&gt;
&lt;p&gt;（考虑到安全，我还是决定自己折腾着玩好了，不过这个场景确实是挺实际的场景）&lt;/p&gt;
&lt;h1&gt;目的&lt;/h1&gt;
&lt;p&gt;这篇文章主要是想在树莓派上练习一下进程管理和开机自启&lt;/p&gt;
&lt;h1&gt;树莓派的入门&lt;/h1&gt;
&lt;p&gt;这类文章网上好多，我自己也有笔记，等有空再整理好了。&lt;/p&gt;
&lt;p&gt;对于装好系统的树莓派（我用的是Raspbian），你就把它当做一个普通的linux便可，没有太多特别的地方（习惯使用Debian/Ubuntu的话，用起来很轻松）&lt;/p&gt;
&lt;h1&gt;安装gogs&lt;/h1&gt;
&lt;h3&gt;目录结构&lt;/h3&gt;
&lt;p&gt;我在HOME目录下建了个文件夹&lt;code&gt;mylab&lt;/code&gt;，用以做实验，gogs也放在这里&lt;/p&gt;
&lt;p&gt;下载二进制安装包：&lt;code&gt;https://dl.gogs.io/gogs_v0.9.60_raspi2.zip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解压：&lt;code&gt;unzip gogs_v0.9.60_raspi2.zip&lt;/code&gt;,于是获得gogs的解压目录：&lt;code&gt;/home/pi/mylab/gogs&lt;/code&gt; （我的操作用户是默认的pi）&lt;/p&gt;
&lt;h3&gt;初始化&lt;/h3&gt;
&lt;p&gt;进入&lt;code&gt;/home/pi/mylab/gogs&lt;/code&gt;目录，将gogs跑起来:&lt;code&gt;./gogs web&lt;/code&gt;,默认跑在3000端口，打开你的&lt;code&gt;ip:3000&lt;/code&gt;,填好内容，就可以初始化了，如果使用sqlite就不需要安装数据库&lt;/p&gt;
&lt;p&gt;初始化完毕我们把&lt;code&gt;./gogs web&lt;/code&gt;断掉（ctrl-c），下边演示使用使用Supervisor来管理进程&lt;/p&gt;
&lt;p&gt;关于gogs的更多细节可以参考我之前的笔记&lt;a href="http://blog.just4fun.site/gogs-install.html"&gt;搭建 gogs 代码托管服务器&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;使用Supervisor来管理gogs进程&lt;/h1&gt;
&lt;p&gt;关于supervisor的介绍和细节何以参考我此前的笔记：&lt;a href="http://blog.just4fun.site/process-control-system-supervisor.html"&gt;使用Supervisor来管理进程&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;sudo pip install supervisor #安装supervisor&lt;/p&gt;
&lt;h3&gt;配置&lt;/h3&gt;
&lt;p&gt;切换到root：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;echo_supervisord_conf &amp;gt; /etc/supervisord.conf
mkdir /etc/supervisord.conf.d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将&lt;code&gt;/etc/supervisord.conf&lt;/code&gt;中的include部分修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[include]&lt;/span&gt;
&lt;span class="na"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/etc/supervisord.conf.d/*.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建&lt;code&gt;/etc/supervisord.conf.d/gogs.conf&lt;/code&gt;,内容如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[program:gogs]&lt;/span&gt;

&lt;span class="na"&gt;user&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;pi&lt;/span&gt;
&lt;span class="na"&gt;directory&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/home/pi/mylab/gogs&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/home/pi/mylab/gogs/gogs web&lt;/span&gt;
&lt;span class="na"&gt;environment&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;HOME=&amp;quot;/home/pi&amp;quot;, USER=&amp;quot;pi&amp;quot;&lt;/span&gt;
&lt;span class="na"&gt;autostart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="na"&gt;autorestart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="na"&gt;startsecs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;10&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/var/log/gogs/stdout.log&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile_maxbytes&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1MB&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile_backups&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;10&lt;/span&gt;
&lt;span class="na"&gt;stdout_capture_maxbytes&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1MB&lt;/span&gt;
&lt;span class="na"&gt;stderr_logfile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/var/log/gogs/stderr.log&lt;/span&gt;
&lt;span class="na"&gt;stderr_logfile_maxbytes&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1MB&lt;/span&gt;
&lt;span class="na"&gt;stderr_logfile_backups&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;10&lt;/span&gt;
&lt;span class="na"&gt;stderr_capture_maxbytes&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1MB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之后就可以使用supervisor来管理gogs了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/usr/local/bin/supervisord 
supervisorctl restart gogs
supervisorctl status
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;开机自启&lt;/h1&gt;
&lt;p&gt;简单的方法是往/etc/rc.local加入/usr/local/bin/supervisord&lt;/p&gt;
&lt;p&gt;重启机器，一切完备！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/pi79409598.png" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Mon, 29 Aug 2016 00:00:00 +0000</pubDate><guid>tag:,2016-08-29:pi-gogs-install.html</guid><category>技术</category></item><item><title>用微信控制树莓派</title><link>/pi-wechat.html</link><description>&lt;p&gt;&lt;img alt="" src="http://oav6fgfj1.bkt.clouddn.com/wechat_pid9f17e53.png" /&gt;&lt;/p&gt;
&lt;h1&gt;源码&lt;/h1&gt;
&lt;p&gt;老习惯，先抛源码，老司机可以直接读&lt;a href="https://github.com/wwj718/raspberrypi_api"&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;动机&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;近期公司有一个有趣的项目，希望用乐高玩具式的可视化编程工具来操控硬件(在网页中)&lt;ul&gt;
&lt;li&gt;所以想把硬件的响应包装为服务&lt;ul&gt;
&lt;li&gt;于是得到可以用微信操作树莓派这个副产品&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;树莓派操控硬件需要有root权限，作为服务之后则没有限制&lt;/li&gt;
&lt;li&gt;解耦&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;想法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;将微信视为控制界面（interface）, 获得联网能力（远程操作）&lt;/li&gt;
&lt;li&gt;将树莓派视为连接代码和物理世界的介质&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;架构设计&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;初期效用flask作为web框架&lt;ul&gt;
&lt;li&gt;使用flask-sockets提供websocket服务:&lt;a href="https://github.com/wwj718/raspberrypi_api/blob/master/led_websocket.py"&gt;led_websocket.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把led_server视为下位机，api视为指令集&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;树莓派与GPIO&lt;/h1&gt;
&lt;p&gt;关于如何使用树莓派的引脚操作外部设备，推荐阅读mango同学的&lt;a href="http://blog.mangolovecarrot.net/2015/04/20/raspi-study01/"&gt;树莓派GPIO入门01-使用GPIO接口控制发光二极管闪烁&lt;/a&gt;，写得十分清楚&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;RPi.GPIO&lt;/code&gt;库，我们几乎不需要硬件的知识，就能轻易地用python代码操控硬件&lt;/p&gt;
&lt;h1&gt;接口定义&lt;/h1&gt;
&lt;p&gt;我们接下来led为例,演示如何将硬件功能暴露为api,可通过http请求，操控硬件（暂不考虑操作权限/安全问题，如果你愿意可以简单定义一个秘钥：&lt;code&gt;?key=xx&lt;/code&gt;），对细节感情兴趣的小伙伴可以跟进我的&lt;a href="https://github.com/wwj718/raspberrypi_api/"&gt;源码库&lt;/a&gt;，我有计划把它做得完备。&lt;/p&gt;
&lt;p&gt;目前我们定义三个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点亮led灯&lt;/li&gt;
&lt;li&gt;熄灭led灯&lt;/li&gt;
&lt;li&gt;使led灯闪烁几次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来使用flask将其暴露出去，成为web api&lt;/p&gt;
&lt;p&gt;代码读起来很容易:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 点亮led灯&lt;/span&gt;
&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/led_up&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led_up&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# 让GPIO14输出高电平（LED灯亮）&lt;/span&gt;
    &lt;span class="n"&gt;RPi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GPIO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ok&amp;#39;&lt;/span&gt;

&lt;span class="c1"&gt;# 熄灭led灯&lt;/span&gt;
&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/led_down&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led_down&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# 让GPIO14输出低电平（LED灯灭）&lt;/span&gt;
    &lt;span class="n"&gt;RPi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GPIO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ok&amp;#39;&lt;/span&gt;

&lt;span class="c1"&gt;# 使led灯闪烁几次&lt;/span&gt;
&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/led_up_down&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;led_up_down&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;RPi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GPIO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# 持续一段时间&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;RPi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GPIO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ok&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完整的源码参考&lt;a href="https://github.com/wwj718/raspberrypi_api/edit/master/led_server.py"&gt;led_server.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在我们可以把服务跑起来了：&lt;code&gt;sudo python led_server.py&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ps： websocket版本参考这里：&lt;a href="https://github.com/wwj718/raspberrypi_api/blob/master/led_websocket.py"&gt;led_websocket.py&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;测试接口&lt;/h1&gt;
&lt;p&gt;我的树莓派当前ip为：192.168.0.106&lt;/p&gt;
&lt;p&gt;我们对这些api进行测试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点亮红灯： curl 192.168.0.106/led_up&lt;/li&gt;
&lt;li&gt;熄灭红灯： curl 192.168.0.106/led_down&lt;/li&gt;
&lt;li&gt;闪啊闪 ： curl 192.168.0.106/led_up_down&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你也可以在浏览器里控制这些灯（使用js）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;XMLHttpRequest&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;http://192.168.0.106/led_up_down&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//闪烁&lt;/span&gt;
&lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;send&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如此一来我们可以在浏览器里操控硬件了&lt;/p&gt;
&lt;h1&gt;对接微信&lt;/h1&gt;
&lt;p&gt;对接微信这步很简单,如果你读过我之前的文章：&lt;a href="http://blog.just4fun.site/create-wechat-bot.html"&gt;把聊天机器人接入微信&lt;/a&gt;，直接看源码就好了。没读过前文也没关系，代码很好理解，我把核心部分列下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wxbot&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;WXBot&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="n"&gt;led_server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://127.0.0.1:5000/&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyWXBot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WXBot&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;正在{}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_msg_by_uid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;led_server&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;
        &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;完成{}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_msg_by_uid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;


    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;handle_msg_all&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;msg_type_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;content&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;user_input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;data&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="c1"&gt;#payload={&amp;quot;user_input&amp;quot;:user_input}&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;关&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;led_down&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;开&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;led_up&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;闪&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_led&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;user_input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;led_up_down&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;源码在这里：&lt;a href="https://github.com/wwj718/raspberrypi_api/blob/master/wechat_pi.py"&gt;wechat_pi.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;跑起来就好：&lt;code&gt;python wechat_pi.py&lt;/code&gt;,由于需要微信扫码，所以先把你的树莓派连到屏幕上（使用图形界面），我使用VNC，之后有空把二维码弄到命令行里&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/wwj718/gif_bed/master/ledf96a0f7d.png" /&gt;&lt;/p&gt;
&lt;h1&gt;脑洞&lt;/h1&gt;
&lt;p&gt;因为微信能在广域网中使用，所以你可以在任何能联网的地方控制树莓派了，进行远程控制，我最近的一个脑洞是在下班路上用微信给树莓派发一个&lt;code&gt;打开空调&lt;/code&gt;的消息，就可以提前打开空调啦&lt;/p&gt;
&lt;p&gt;原理也很简单使用红外接收器学习空调遥控器的指令集（目前只要开关机的指令），然后使用红外发射器伪造成遥控器控制空调。最后对接到微信即可&lt;/p&gt;
&lt;p&gt;目前采集红外信号部分已经完成了&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Mon, 29 Aug 2016 00:00:00 +0000</pubDate><guid>tag:,2016-08-29:pi-wechat.html</guid><category>技术</category></item><item><title>搭建 gogs 代码托管服务器</title><link>/gogs-install.html</link><description>&lt;p&gt;前头写到搭建好了gitlab，不过没有找到汉化的方法，而且看去界面蛮繁琐的（针对没有使用github的同学而言）。为了降低大家入门门槛，决定使用gogs来搭建代码托管服务器。&lt;/p&gt;
&lt;h1&gt;gogs&lt;/h1&gt;
&lt;p&gt;github上的star截止至15.08.03，已经超过8k。自助安装极其方便，有各个平台的二进制文件，甚至可以轻易搭建在树莓派上&lt;/p&gt;
&lt;h1&gt;install&lt;/h1&gt;
&lt;h2&gt;安装mysql&lt;/h2&gt;
&lt;p&gt;你也可以不安装任何数据库，默认会使用sqlite&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install mysql-server
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进入mysql，创建好数据库：&lt;code&gt;CREATE DATABASE gogs;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;安装gogs&lt;/h2&gt;
&lt;p&gt;采用二进制安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget http://gogs.dn.qbox.me/gogs_v0.6.3_linux_amd64.zip
unzip gogs_v0.6.3_linux_amd64.zip
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;run it&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;chmod +x gogs
./gogs web
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;跑起来后进入到一个安装配置页面,邮件服务器的配置需要注意一下端口号，举个栗子：&lt;code&gt;smtp.qq.com:25&lt;/code&gt;.此外注意一下当出现&lt;code&gt;运行系统用户非当前用户&lt;/code&gt;错误是，在配置里填上你运行&lt;code&gt;./gogs web&lt;/code&gt;对应的用户&lt;/p&gt;
&lt;p&gt;如果需要修改配置文件，只要编辑gogs目录下的:&lt;code&gt;custom/conf/app.ini&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;整个过程极其建议&lt;/p&gt;
&lt;p&gt;ps:管理员可以不设置，第一个注册的用户将被认为是管理员&lt;/p&gt;
&lt;p&gt;如果要reinstall，只要把data和custom目录删除即可&lt;/p&gt;
&lt;h2&gt;备份&lt;/h2&gt;
&lt;p&gt;默认情况下，代码仓库在&lt;code&gt;~/gogs-repositories&lt;/code&gt;下，备份的话除了备份数据库(gogs/data)，也注意备份这个目录，推荐使用backup，我在此前的一篇博客里有提到:&lt;a href="http://wwj718.github.io/use-backup-for-edx.html"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;backup的安装非常蛋疼，在ruby1.9中各种出错，还是使用rsync好了&lt;/p&gt;
&lt;h3&gt;使用rsync同步数据&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;配置好ssh免登陆&lt;ul&gt;
&lt;li&gt;ssh-keygen -t dsa&lt;/li&gt;
&lt;li&gt;sudo cp -R .ssh /root/&lt;/li&gt;
&lt;li&gt;ssh-copy-id -i .ssh/id_dsa.pub xx@backup_host&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地推送到远程：&lt;code&gt;/usr/bin/rsync -avH  /home/xx/gogs-repositories xx@backup_host:~/backup/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;备份mysql数据    &lt;ul&gt;
&lt;li&gt;/usr/bin/mysqldump -uroot -pxxx gogs &amp;gt; /tmp/gogs.sql  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用cron写定时任务&lt;ul&gt;
&lt;li&gt;&lt;code&gt;00 01 * * * /usr/bin/rsync xxx&lt;/code&gt; （每天凌晨1点同步数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;使用Supervisor管理进程&lt;/h1&gt;
&lt;p&gt;参考&lt;a href="http://blog.just4fun.site/process-control-system-supervisor.html"&gt;使用Supervisor来管理进程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;/etc/supervisord.conf.d/&lt;/code&gt;创建&lt;code&gt;gogs.conf&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[program:gogs]

user=wwj
directory=/home/wwj/gogs/gogs
command=/home/wwj/gogs/gogs/gogs web
environment = HOME=&amp;quot;/home/wwj&amp;quot;, USER=&amp;quot;wwj&amp;quot;
autostart=true
autorestart=true
startsecs=10
stdout_logfile=/var/log/gogs/stdout.log
stdout_logfile_maxbytes=1MB
stdout_logfile_backups=10
stdout_capture_maxbytes=1MB
stderr_logfile=/var/log/gogs/stderr.log
stderr_logfile_maxbytes=1MB
stderr_logfile_backups=10
stderr_capture_maxbytes=1MB
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;supervisorctl  restart gogs&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wuwenjie</dc:creator><pubDate>Mon, 03 Aug 2015 00:00:00 +0000</pubDate><guid>tag:,2015-08-03:gogs-install.html</guid><category>技术</category></item></channel></rss>